(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

Object.assign(module.exports, require('d3-array'), require('d3-shape'), require('d3-selection'), require('d3-axis'), require('d3-scale'), require('d3-scale-chromatic'));

},{"d3-array":30,"d3-axis":31,"d3-scale":38,"d3-scale-chromatic":37,"d3-selection":39,"d3-shape":40}],2:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var d3 = require('../d3.js');

var cephes = require('../../');

function linspace(start, stop, nsteps) {
  var delta = (stop - start) / (nsteps - 1);
  return d3.range(start, stop + delta, delta).slice(0, nsteps);
}

var LazyGraphs =
/*#__PURE__*/
function () {
  function LazyGraphs() {
    (0, _classCallCheck2.default)(this, LazyGraphs);
    this._computed = new Map();
  }

  (0, _createClass2.default)(LazyGraphs, [{
    key: "get",
    value: function get(exampleNumber) {
      if (this._computed.has(exampleNumber)) {
        return this._computed.get(exampleNumber);
      }

      var data;

      switch (exampleNumber) {
        case 1:
          data = this._bessel();
          break;

        case 2:
          data = this._gamma();
          break;

        case 3:
          data = this._beta();
          break;

        case 4:
          data = this._ariy();
          break;

        default:
          throw new Error("example ".concat(exampleNumber, " is not supported"));
      }

      this._computed.set(exampleNumber, data);

      return data;
    }
  }, {
    key: "_gamma",
    value: function _gamma() {
      var xInput = linspace(0.001, 5, 100);
      return {
        xDomain: [0.001, 5],
        yDomain: [-5, 5],
        lines: [{
          line: xInput.map(function (x) {
            return [x, cephes.gamma(x)];
          }),
          description: "Gamma(x)"
        }, {
          line: xInput.map(function (x) {
            return [x, cephes.lgam(x)];
          }),
          description: "ln(Gamma(x))"
        }, {
          line: xInput.map(function (x) {
            return [x, cephes.psi(x)];
          }),
          description: "DiGamma(x)"
        }]
      };
    }
  }, {
    key: "_beta",
    value: function _beta() {
      var xInput = linspace(0.0001, 0.9999, 100);

      function betadist(alpha, beta, x) {
        return Math.pow(x, alpha - 1) * Math.pow(1 - x, beta - 1) / cephes.beta(alpha, beta);
      }

      return {
        xDomain: [0, 1],
        yDomain: [0, 2.5],
        lines: [{
          line: xInput.map(function (x) {
            return [x, betadist(0.5, 0.5, x)];
          }),
          description: "BetaDistribution(x; 0.5, 0.5)"
        }, {
          line: xInput.map(function (x) {
            return [x, betadist(5, 1, x)];
          }),
          description: "BetaDistribution(x; 5, 1)"
        }, {
          line: xInput.map(function (x) {
            return [x, betadist(1, 3, x)];
          }),
          description: "BetaDistribution(x; 1, 3)"
        }, {
          line: xInput.map(function (x) {
            return [x, betadist(2, 2, x)];
          }),
          description: "BetaDistribution(x; 2, 2)"
        }, {
          line: xInput.map(function (x) {
            return [x, betadist(2, 5, x)];
          }),
          description: "BetaDistribution(x; 2, 5)"
        }]
      };
    }
  }, {
    key: "_bessel",
    value: function _bessel() {
      var xInput = linspace(0, 20, 100);
      return {
        xDomain: [0, 20],
        yDomain: [-1, 1],
        lines: [{
          line: xInput.map(function (x) {
            return [x, cephes.j0(x)];
          }),
          description: "Bessel(0, x)"
        }, {
          line: xInput.map(function (x) {
            return [x, cephes.jv(0.5, x)];
          }),
          description: "Bessel(0.5, x)"
        }, {
          line: xInput.map(function (x) {
            return [x, cephes.j1(x)];
          }),
          description: "Bessel(1, x)"
        }, {
          line: xInput.map(function (x) {
            return [x, cephes.jv(1.5, x)];
          }),
          description: "Bessel(1.5, x)"
        }, {
          line: xInput.map(function (x) {
            return [x, cephes.jv(2, x)];
          }),
          description: "Bessel(2, x)"
        }]
      };
    }
  }, {
    key: "_ariy",
    value: function _ariy() {
      var xInput = linspace(-10, 5, 100);
      var yResult = xInput.map(function (x) {
        return cephes.airy(x);
      });
      return {
        xDomain: [-10, 5],
        yDomain: [-2, 2],
        lines: [{
          line: xInput.map(function (x, i) {
            var _yResult$i = (0, _slicedToArray2.default)(yResult[i], 2),
                ret = _yResult$i[0],
                _yResult$i$ = _yResult$i[1],
                ai = _yResult$i$.ai,
                aip = _yResult$i$.aip,
                bi = _yResult$i$.bi,
                bip = _yResult$i$.bip;

            return [x, ai];
          }),
          description: "Ai(x)"
        }, {
          line: xInput.map(function (x, i) {
            var _yResult$i2 = (0, _slicedToArray2.default)(yResult[i], 2),
                ret = _yResult$i2[0],
                _yResult$i2$ = _yResult$i2[1],
                ai = _yResult$i2$.ai,
                aip = _yResult$i2$.aip,
                bi = _yResult$i2$.bi,
                bip = _yResult$i2$.bip;

            return [x, aip];
          }),
          description: "Ai'(x)"
        }, {
          line: xInput.map(function (x, i) {
            var _yResult$i3 = (0, _slicedToArray2.default)(yResult[i], 2),
                ret = _yResult$i3[0],
                _yResult$i3$ = _yResult$i3[1],
                ai = _yResult$i3$.ai,
                aip = _yResult$i3$.aip,
                bi = _yResult$i3$.bi,
                bip = _yResult$i3$.bip;

            return [x, bi];
          }),
          description: "Bi(x)"
        }, {
          line: xInput.map(function (x, i) {
            var _yResult$i4 = (0, _slicedToArray2.default)(yResult[i], 2),
                ret = _yResult$i4[0],
                _yResult$i4$ = _yResult$i4[1],
                ai = _yResult$i4$.ai,
                aip = _yResult$i4$.aip,
                bi = _yResult$i4$.bi,
                bip = _yResult$i4$.bip;

            return [x, bip];
          }),
          description: "Bi'(x)"
        }]
      };
    }
  }]);
  return LazyGraphs;
}();

module.exports = LazyGraphs;

},{"../../":8,"../d3.js":1,"@babel/runtime/helpers/classCallCheck":13,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/interopRequireDefault":17,"@babel/runtime/helpers/slicedToArray":24}],3:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var d3 = require('../d3.js');

var margin = {
  top: 10,
  right: 10,
  bottom: 10,
  left: 10
};
var xAxisHeight = 20;
var yAxisWidth = 20;
var legendItemRectSize = 24;
var legendItemTextMargin = 4;

function iseq(array) {
  var seq = [];

  for (var i = 0; i < array.length; i++) {
    seq.push(i);
  }

  return seq;
}

var LineGraph =
/*#__PURE__*/
function () {
  function LineGraph(_ref) {
    var _this = this;

    var container = _ref.container,
        height = _ref.height,
        _ref$colors = _ref.colors,
        colors = _ref$colors === void 0 ? d3.schemePaired : _ref$colors;
    (0, _classCallCheck2.default)(this, LineGraph);
    this._container = d3.select(container);
    this._height = height;
    this._colors = colors;
    this._innerHeight = height - margin.top - margin.bottom - xAxisHeight;
    this._data = null;
    this._svg = this._container.append('svg').attr('height', this._height);

    this._svg.node().setAttribute('xmlns', 'http://www.w3.org/2000/svg');

    this._svg.node().setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');

    this._legend = this._container.append('div').classed('legend', true).style('margin-left', "".concat(margin.left + yAxisWidth, "px")).style('margin-right', "".concat(margin.right, "px"));
    this._clipRect = this._svg.append('defs').append('clipPath').attr('id', 'ar-line-graph-clip').append('rect').attr('height', this._innerHeight);
    this._graph = this._svg.append('g').attr('transform', 'translate(' + (margin.left + yAxisWidth) + ',' + margin.top + ')'); // Create background

    this._background = this._graph.append("rect").attr("class", "background").attr("height", this._innerHeight); // define scales

    this._colorScale = d3.scaleOrdinal();
    this._xScale = d3.scaleLinear().domain([1, 0]);
    this._yScale = d3.scaleLinear().domain([1, 0]).range([this._innerHeight, 0]); // create grid

    this._xGrid = d3.axisBottom(this._xScale).ticks(8).tickSize(-this._height);
    this._xGridElement = this._graph.append("g").attr("class", "grid").attr("transform", "translate(0," + this._innerHeight + ")"); // create grid

    this._yGrid = d3.axisLeft(this._yScale).ticks(8);
    this._yGridElement = this._graph.append("g").attr("class", "grid"); // define axis

    this._xAxis = d3.axisBottom(this._xScale).ticks(4);
    this._xAxisElement = this._graph.append('g').attr("class", "axis").attr('transform', 'translate(0,' + this._innerHeight + ')');
    this._yAxis = d3.axisLeft(this._yScale).ticks(4);
    this._yAxisElement = this._graph.append('g').attr("class", "axis");
    this._yAxisTitle = this._graph.append('g').attr("class", "axis-title");
    this._lines = this._graph.append("g").classed('lines', true);
    this._lineDrawer = d3.line().curve(d3.curveBasis).x(function (d) {
      return _this._xScale(d[0]);
    }).y(function (d) {
      return _this._yScale(d[1]);
    });
  }

  (0, _createClass2.default)(LineGraph, [{
    key: "setData",
    value: function setData(data) {
      this._data = data;
    }
  }, {
    key: "draw",
    value: function draw() {
      this._colorScale.domain(iseq(this._data.lines.length)).range(this._colors.slice(0, this._data.lines.length));

      this._yScale.domain(this._data.yDomain);

      this._xScale.domain(this._data.xDomain);

      this._drawLegend();

      this.resize();
    }
  }, {
    key: "_drawLegend",
    value: function _drawLegend() {
      var _this2 = this;

      var legendSelectPhase1 = this._legend.selectAll('svg.legend-item').data(this._data.lines);

      legendSelectPhase1.select('.legend-color').style('fill', function (d, i) {
        return _this2._colorScale(i);
      });
      legendSelectPhase1.select('.legend-text').text(function (d) {
        return d.description;
      });
      var lengedGroupEnter = legendSelectPhase1.enter().append('svg').attr('height', legendItemRectSize).classed('legend-item', true);
      lengedGroupEnter.append('rect').classed('legend-background', true).attr('width', legendItemRectSize).attr('height', legendItemRectSize);
      lengedGroupEnter.append('text').classed('legend-color', true).style('fill', function (d, i) {
        return _this2._colorScale(i);
      }).attr('x', legendItemRectSize / 2).attr('y', legendItemRectSize / 2).text('–');
      lengedGroupEnter.append('text').classed('legend-text', true).attr('x', legendItemRectSize + legendItemTextMargin).attr('y', legendItemRectSize / 2).text(function (d) {
        return d.description;
      });
      legendSelectPhase1.exit().remove();

      var legendSelectPhase2 = this._legend.selectAll('svg.legend-item').data(this._colorScale.domain());

      legendSelectPhase2.attr('width', function () {
        return legendItemRectSize + legendItemTextMargin + this.querySelector('.legend-text').getComputedTextLength();
      });

      this._legend.style('grid-template-columns', function () {
        var maxWidth = Math.max.apply(Math, (0, _toConsumableArray2.default)(Array.from(this.querySelectorAll('svg.legend-item')).map(function (elem) {
          return Math.ceil(parseInt(elem.getAttribute('width')));
        })));
        return "repeat(auto-fit, minmax(".concat(Math.ceil(maxWidth), "px, 1fr)");
      });
    }
  }, {
    key: "resize",
    value: function resize() {
      var _this3 = this;

      var width = this._container.node().clientWidth;

      var innerWidth = width - (margin.left + margin.right + yAxisWidth);

      this._svg.attr('width', width);

      this._clipRect.attr('width', innerWidth); // set background


      this._background.attr("width", innerWidth); // set the ranges


      this._xScale.range([0, innerWidth]); // update grid


      this._yGrid.tickSize(-innerWidth);

      var yTicksMajors = this._yScale.ticks(4);

      this._yGridElement.call(this._yGrid);

      this._yGridElement.selectAll('.tick').classed('minor', function (d) {
        return !yTicksMajors.includes(d);
      });

      var xTicksMajors = [0, 6, 12, 18, 24];

      this._xGridElement.call(this._xGrid);

      this._xGridElement.selectAll('.tick').classed('minor', function (d) {
        return !xTicksMajors.includes(d);
      }); // update axis


      this._xAxisElement.call(this._xAxis);

      this._yAxisElement.call(this._yAxis); // draw lines


      var curveSelect = this._lines.selectAll('path.mathline').data(this._data.lines);

      curveSelect.attr('d', function (d) {
        return _this3._lineDrawer(d.line);
      }).style("stroke", function (d, i) {
        return _this3._colorScale(i);
      });
      curveSelect.enter().append("path").attr('class', 'mathline').attr('clip-path', 'url(#ar-line-graph-clip)').attr('d', function (d) {
        return _this3._lineDrawer(d.line);
      }).style("stroke", function (d, i) {
        return _this3._colorScale(i);
      });
      curveSelect.exit().remove();
    }
  }]);
  return LineGraph;
}();

module.exports = LineGraph;

},{"../d3.js":1,"@babel/runtime/helpers/classCallCheck":13,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/interopRequireDefault":17,"@babel/runtime/helpers/toConsumableArray":25}],4:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var events = require('events');

var d3 = require('../d3.js');

var Walkthrough =
/*#__PURE__*/
function (_events$EventEmitter) {
  (0, _inherits2.default)(Walkthrough, _events$EventEmitter);

  function Walkthrough(_ref) {
    var _this;

    var container = _ref.container;
    (0, _classCallCheck2.default)(this, Walkthrough);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Walkthrough).call(this));
    _this._container = d3.select(container);
    _this._steps = _this._container.selectAll('.ar-walkthrough-step');
    _this._pages = _this._container.selectAll('.ar-walkthrough-page').on('click', function (d) {
      return _this.emit('click', d);
    });

    var itemNumbers = _this._steps.nodes().map(function (element, index) {
      return index + 1;
    });

    _this._pages.data(itemNumbers);

    _this._steps.data(itemNumbers);

    _this._selectedItem = 1;
    return _this;
  }

  (0, _createClass2.default)(Walkthrough, [{
    key: "select",
    value: function select(itemNumber) {
      this._selectedItem = itemNumber;
    }
  }, {
    key: "draw",
    value: function draw() {
      var _this2 = this;

      this._steps.classed('ar-walkthrough-selected', function (d) {
        return d === _this2._selectedItem;
      });
    }
  }]);
  return Walkthrough;
}(events.EventEmitter);

module.exports = Walkthrough;

},{"../d3.js":1,"@babel/runtime/helpers/classCallCheck":13,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/getPrototypeOf":15,"@babel/runtime/helpers/inherits":16,"@babel/runtime/helpers/interopRequireDefault":17,"@babel/runtime/helpers/possibleConstructorReturn":22,"events":45}],5:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var cephes = require('../');

var d3 = require('./d3.js');

var LazyGraphs = require('./lib/lazy-graphs.js');

var Walkthrough = require('./lib/walkthrough.js');

var LineGraph = require('./lib/line-graph.js');

var colors = d3.schemeCategory10;

function setupDiagram() {
  return _setupDiagram.apply(this, arguments);
}

function _setupDiagram() {
  _setupDiagram = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee() {
    var graphs, walkthrough, lineGraph;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            graphs = new LazyGraphs();
            walkthrough = new Walkthrough({
              container: document.querySelector('#ar-walkthrough')
            });
            lineGraph = new LineGraph({
              container: document.querySelector('#ar-line-graph'),
              height: 400,
              colors: colors
            });
            walkthrough.select(1);
            lineGraph.setData(graphs.get(1));
            lineGraph.draw();
            walkthrough.draw();
            walkthrough.on('click', function (pageNumber) {
              walkthrough.select(pageNumber);
              lineGraph.setData(graphs.get(pageNumber));
              walkthrough.draw();
              lineGraph.draw();
            });
            window.addEventListener('resize', function () {
              lineGraph.resize();
            });

          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _setupDiagram.apply(this, arguments);
}

function main() {
  return _main.apply(this, arguments);
}

function _main() {
  _main = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee2() {
    var elements;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            // Render LaTeX elements first, as their size is unknown.
            elements = document.querySelectorAll('math-latex');
            Array.from(elements).forEach(function processElement(element) {
              window.katex.render(element.getAttribute('latex'), element, {
                displayMode: element.hasAttribute('display-mode')
              });
            });
            _context2.next = 4;
            return cephes.compiled;

          case 4:
            _context2.next = 6;
            return setupDiagram();

          case 6:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _main.apply(this, arguments);
}

document.addEventListener('DOMContentLoaded', main);

},{"../":8,"./d3.js":1,"./lib/lazy-graphs.js":2,"./lib/line-graph.js":3,"./lib/walkthrough.js":4,"@babel/runtime/helpers/asyncToGenerator":12,"@babel/runtime/helpers/interopRequireDefault":17,"@babel/runtime/regenerator":29}],6:[function(require,module,exports){
"use strict";

var CephesWrapper = require('./cephes-wrapper.js'); // Compile async in the browser


module.exports = new CephesWrapper(false);

},{"./cephes-wrapper.js":7}],7:[function(require,module,exports){
(function (Buffer){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));



var TOTAL_STACK = 1024 * 1024; // 1MB

var TOTAL_MEMORY = 1024 * 1024; // 1MB

var WASM_PAGE_SIZE = 64 * 1024; // Defined in WebAssembly specs
// This must be brfs friendly -- see https://github.com/browserify/brfs

var WASM_CODE = Buffer("AGFzbQEAAAABlgEXYAJ/fwF/YAF/AX9gAAF/YAF/AGACf38AYAF8AXxgBXx/f39/AX9gAnx8AXxgA39/fAF8YAN8fHwBfGADfH9/AXxgBnx8f39/fwF/YAJ/fAF8YAJ8fwF8YAF/AXxgA3x/fwF/YAR8fHx8AXxgBXx8fHx/AXxgBXx8fH9/AXxgAXwBf2AEf3x/fwF8YAR8f39/AX9gAAACPwQDZW52Bm1lbW9yeQIBEBADZW52CFNUQUNLVE9QA38AA2VudglTVEFDS19NQVgDfwADZW52B19tdGhlcnIAAAORAY8BAQIDBAQDAgUGBQUFBQcFCAgIBwcJBQoHBwcFBQUHBwULBQUFBQwNDggICA0NDwUFCQkQEQkSBQUFBQcHBwkJCRMTEwcFBQUFDAcHBxQFBQUFDAwFDAUFBQUICAgFBQUFDAwMBwcHBQoKDAcNBQUFDw8FBQkVBQUFBQwMEREHBwUNBQUNBQUFBQUMBwUBAxYGGgV/ASMAC38BIwELfwFBAAt/AUEAC38BQQALB8QQiAEMX2NlcGhlc19hY29zAAsNX2NlcGhlc19hY29zaAAIDF9jZXBoZXNfYWlyeQAJDF9jZXBoZXNfYXNpbgAKDV9jZXBoZXNfYXNpbmgADAxfY2VwaGVzX2F0YW4ADQ1fY2VwaGVzX2F0YW4yAA4NX2NlcGhlc19hdGFuaAAPDF9jZXBoZXNfYmR0cgARDV9jZXBoZXNfYmR0cmMAEA1fY2VwaGVzX2JkdHJpABIMX2NlcGhlc19iZXRhABMNX2NlcGhlc19idGR0cgAVDF9jZXBoZXNfY2JydAAWDl9jZXBoZXNfY2hiZXZsABcNX2NlcGhlc19jaGR0cgAZDl9jZXBoZXNfY2hkdHJjABgOX2NlcGhlc19jaGR0cmkAGgtfY2VwaGVzX2NvcwBzDV9jZXBoZXNfY29zZGcAdwxfY2VwaGVzX2Nvc2gAGw1fY2VwaGVzX2Nvc20xAIkBC19jZXBoZXNfY290AIIBDV9jZXBoZXNfY290ZGcAhQENX2NlcGhlc19kYXdzbgAcCl9jZXBoZXNfZWkAHQ1fY2VwaGVzX2VsbGllAB4NX2NlcGhlc19lbGxpawAfDV9jZXBoZXNfZWxscGUAIA1fY2VwaGVzX2VsbHBqACENX2NlcGhlc19lbGxwawAiC19jZXBoZXNfZXJmAF8MX2NlcGhlc19lcmZjAF4LX2NlcGhlc19leHAAIw1fY2VwaGVzX2V4cDEwACQMX2NlcGhlc19leHAyACUNX2NlcGhlc19leHBtMQCIAQxfY2VwaGVzX2V4cG4AJg1fY2VwaGVzX2V4cHgyACcLX2NlcGhlc19mYWMAKAxfY2VwaGVzX2ZkdHIAKg1fY2VwaGVzX2ZkdHJjACkNX2NlcGhlc19mZHRyaQArDl9jZXBoZXNfZnJlc25sAC4NX2NlcGhlc19mcmV4cAAsDV9jZXBoZXNfZ2FtbWEALwxfY2VwaGVzX2dkdHIAMQ1fY2VwaGVzX2dkdHJjADIOX2NlcGhlc19oeXAyZjAANg5fY2VwaGVzX2h5cDJmMQAzDl9jZXBoZXNfaHlwZXJnADUKX2NlcGhlc19pMAA3C19jZXBoZXNfaTBlADgKX2NlcGhlc19pMQA5C19jZXBoZXNfaTFlADoMX2NlcGhlc19pZ2FtADwNX2NlcGhlc19pZ2FtYwA7DV9jZXBoZXNfaWdhbWkAPQ5fY2VwaGVzX2luY2JldAA+DV9jZXBoZXNfaW5jYmkAQBBfY2VwaGVzX2lzZmluaXRlAEMNX2NlcGhlc19pc25hbgBCCl9jZXBoZXNfaXYARApfY2VwaGVzX2owAEUKX2NlcGhlc19qMQBHCl9jZXBoZXNfam4ASQpfY2VwaGVzX2p2AEoKX2NlcGhlc19rMABOC19jZXBoZXNfazBlAE8KX2NlcGhlc19rMQBQC19jZXBoZXNfazFlAFEKX2NlcGhlc19rbgBSD19jZXBoZXNfa29sbW9naQBWEl9jZXBoZXNfa29sbW9nb3JvdgBUDV9jZXBoZXNfbGJldGEAFA1fY2VwaGVzX2xkZXhwAC0MX2NlcGhlc19sZ2FtADALX2NlcGhlc19sb2cAVw1fY2VwaGVzX2xvZzEwAFgNX2NlcGhlc19sb2cxcACHAQxfY2VwaGVzX2xvZzIAWQ1fY2VwaGVzX25iZHRyAFsOX2NlcGhlc19uYmR0cmMAWg5fY2VwaGVzX25iZHRyaQBcDF9jZXBoZXNfbmR0cgBdDV9jZXBoZXNfbmR0cmkAYA1fY2VwaGVzX29uZWYyAHwNX2NlcGhlc19wMWV2bABpDF9jZXBoZXNfcGR0cgBiDV9jZXBoZXNfcGR0cmMAYQ1fY2VwaGVzX3BkdHJpAGMPX2NlcGhlc19wbGFuY2tjAGUPX2NlcGhlc19wbGFuY2tkAGYPX2NlcGhlc19wbGFuY2tpAGQPX2NlcGhlc19wbGFuY2t3AGcOX2NlcGhlc19wb2xldmwAaA9fY2VwaGVzX3BvbHlsb2cAagtfY2VwaGVzX3BvdwBrDF9jZXBoZXNfcG93aQBsC19jZXBoZXNfcHNpAG0OX2NlcGhlc19yYWRpYW4AdA5fY2VwaGVzX3JnYW1tYQBuDV9jZXBoZXNfcm91bmQAbw5fY2VwaGVzX3NoaWNoaQBwDF9jZXBoZXNfc2ljaQBxD19jZXBoZXNfc2lnbmJpdABBC19jZXBoZXNfc2luAHIOX2NlcGhlc19zaW5jb3MAdQ1fY2VwaGVzX3NpbmRnAHYMX2NlcGhlc19zaW5oAHgPX2NlcGhlc19zbWlybm92AFMQX2NlcGhlc19zbWlybm92aQBVDl9jZXBoZXNfc3BlbmNlAHkNX2NlcGhlc19zdGR0cgB6Dl9jZXBoZXNfc3RkdHJpAHsOX2NlcGhlc19zdHJ1dmUAfgtfY2VwaGVzX3RhbgCAAQ1fY2VwaGVzX3RhbmRnAIMBDF9jZXBoZXNfdGFuaACGAQ9fY2VwaGVzX3RocmVlZjAAfQpfY2VwaGVzX3kwAEYKX2NlcGhlc195MQBICl9jZXBoZXNfeW4AigEKX2NlcGhlc195dgB/DF9jZXBoZXNfemV0YQCLAQ1fY2VwaGVzX3pldGFjAIwBBV9mcmVlAI4BB19tYWxsb2MAjQETZXN0YWJsaXNoU3RhY2tTcGFjZQAEC2dldFRlbXBSZXQwAAcLcnVuUG9zdFNldHMAjwELc2V0VGVtcFJldDAABghzZXRUaHJldwAFCnN0YWNrQWxsb2MAAQxzdGFja1Jlc3RvcmUAAwlzdGFja1NhdmUAAgrYhAOPARsBAX8jAiEBIwIgAGokAiMCQQ9qQXBxJAIgAQsEACMCCwYAIAAkAgsKACAAJAIgASQDCxAAIwRFBEAgACQEIAEkBQsLBgAgACQGCwQAIwYLmgEBAXwgAEQAAAAAAADwP2MEQEGA8wBBARAAGkHw8gArAwAPCyAARAAAAACE15dBZARAQejyACsDACIBIABhBEAgAQ8LIAAQV0HQ8gArAwCgDwsgAEQAAAAAAADw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Ofr+Qi6GQFIwLdUQSYfA////////738YLURU+yEJQBgtRFT7Ifk/GC1EVPsh6T/NO39mnqDmP/6CK2VHFfc/UTbUM0WI6T/vOfr+Qi7mP9IhM3982QJAg8jJbTBf5D8AAAAAAADwfwAAAAAAAPx/AAAAAAAAAIBhY29zaABhc2luAGFjb3MAYXRhbmgAYmR0cmMAYmR0cgBiZHRyaQBiZXRhAGxiZXRhAGNoZHRyYwBjaGR0cgBjaGR0cmkAY29zaABlaQBlbGxpawBlbGxwZQBlbGxwagBlbGxwawBleHBuAGZhYwBmZHRyYwBmZHRyAGZkdHJpAGdhbW1hAGxnYW0AZ2R0cgBnZHRyYwBoeXAyZjEAaHlwZXJnAGlnYW1jAGlnYW0AaWdhbWkAaW5jYmV0AGluY2JpAGl2AHkwAHkxAEp2AGp2AGswAGswZQBrMQBrMWUAa24Ac21pcm5vdmkAa29sbW9naQBsb2cAbG9nMTAAbG9nMgBuYmR0cgBuYmR0cmkAZXJmYwBuZHRyaQBwZHRyYwBwZHRyAHBkdHJpAHBvbHlsb2cAcG93AHBvdwBwb3dpAHBzaQByZ2FtbWEAc2luAGNvcwBzaW5kZwBjb3NkZwBzaW5oAHNwZW5jZQBzdGR0cgBzdGR0cmkAdGFuAGNvdAB0YW5kZwBjb3RkZwB5bgB6ZXRhAHpldGFjAI8QBG5hbWUBhxCQAQAHX210aGVycgEKc3RhY2tBbGxvYwIJc3RhY2tTYXZlAwxzdGFja1Jlc3RvcmUEE2VzdGFibGlzaFN0YWNrU3BhY2UFCHNldFRocmV3BgtzZXRUZW1wUmV0MAcLZ2V0VGVtcFJldDAIDV9jZXBoZXNfYWNvc2gJDF9jZXBoZXNfYWlyeQoMX2NlcGhlc19hc2luCwxfY2VwaGVzX2Fjb3MMDV9jZXBoZXNfYXNpbmgNDF9jZXBoZXNfYXRhbg4NX2NlcGhlc19hdGFuMg8NX2NlcGhlc19hdGFuaBANX2NlcGhlc19iZHRyYxEMX2NlcGhlc19iZHRyEg1fY2VwaGVzX2JkdHJpEwxfY2VwaGVzX2JldGEUDV9jZXBoZXNfbGJldGEVDV9jZXBoZXNfYnRkdHIWDF9jZXBoZXNfY2JydBcOX2NlcGhlc19jaGJldmwYDl9jZXBoZXNfY2hkdHJjGQ1fY2VwaGVzX2NoZHRyGg5fY2VwaGVzX2NoZHRyaRsMX2NlcGhlc19jb3NoHA1fY2VwaGVzX2Rhd3NuHQpfY2VwaGVzX2VpHg1fY2VwaGVzX2VsbGllHw1fY2VwaGVzX2VsbGlrIA1fY2VwaGVzX2VsbHBlIQ1fY2VwaGVzX2VsbHBqIg1fY2VwaGVzX2VsbHBrIwtfY2VwaGVzX2V4cCQNX2NlcGhlc19leHAxMCUMX2NlcGhlc19leHAyJgxfY2VwaGVzX2V4cG4nDV9jZXBoZXNfZXhweDIoC19jZXBoZXNfZmFjKQ1fY2VwaGVzX2ZkdHJjKgxfY2VwaGVzX2ZkdHIrDV9jZXBoZXNfZmR0cmksDV9jZXBoZXNfZnJleHAtDV9jZXBoZXNfbGRleHAuDl9jZXBoZXNfZnJlc25sLw1fY2VwaGVzX2dhbW1hMAxfY2VwaGVzX2xnYW0xDF9jZXBoZXNfZ2R0cjINX2NlcGhlc19nZHRyYzMOX2NlcGhlc19oeXAyZjE0B19oeXQyZjE1Dl9jZXBoZXNfaHlwZXJnNg5fY2VwaGVzX2h5cDJmMDcKX2NlcGhlc19pMDgLX2NlcGhlc19pMGU5Cl9jZXBoZXNfaTE6C19jZXBoZXNfaTFlOw1fY2VwaGVzX2lnYW1jPAxfY2VwaGVzX2lnYW09DV9jZXBoZXNfaWdhbWk+Dl9jZXBoZXNfaW5jYmV0PwhfcHNlcmllc0ANX2NlcGhlc19pbmNiaUEPX2NlcGhlc19zaWduYml0Qg1fY2VwaGVzX2lzbmFuQxBfY2VwaGVzX2lzZmluaXRlRApfY2VwaGVzX2l2RQpfY2VwaGVzX2owRgpfY2VwaGVzX3kwRwpfY2VwaGVzX2oxSApfY2VwaGVzX3kxSQpfY2VwaGVzX2puSgpfY2VwaGVzX2p2SwRfanZzTAdfaGFua2VsTQZfcmVjdXJOCl9jZXBoZXNfazBPC19jZXBoZXNfazBlUApfY2VwaGVzX2sxUQtfY2VwaGVzX2sxZVIKX2NlcGhlc19rblMPX2NlcGhlc19zbWlybm92VBJfY2VwaGVzX2tvbG1vZ29yb3ZVEF9jZXBoZXNfc21pcm5vdmlWD19jZXBoZXNfa29sbW9naVcLX2NlcGhlc19sb2dYDV9jZXBoZXNfbG9nMTBZDF9jZXBoZXNfbG9nMloOX2NlcGhlc19uYmR0cmNbDV9jZXBoZXNfbmJkdHJcDl9jZXBoZXNfbmJkdHJpXQxfY2VwaGVzX25kdHJeDF9jZXBoZXNfZXJmY18LX2NlcGhlc19lcmZgDV9jZXBoZXNfbmR0cmlhDV9jZXBoZXNfcGR0cmNiDF9jZXBoZXNfcGR0cmMNX2NlcGhlc19wZHRyaWQPX2NlcGhlc19wbGFuY2tpZQ9fY2VwaGVzX3BsYW5ja2NmD19jZXBoZXNfcGxhbmNrZGcPX2NlcGhlc19wbGFuY2t3aA5fY2VwaGVzX3BvbGV2bGkNX2NlcGhlc19wMWV2bGoPX2NlcGhlc19wb2x5bG9nawtfY2VwaGVzX3Bvd2wMX2NlcGhlc19wb3dpbQtfY2VwaGVzX3BzaW4OX2NlcGhlc19yZ2FtbWFvDV9jZXBoZXNfcm91bmRwDl9jZXBoZXNfc2hpY2hpcQxfY2VwaGVzX3NpY2lyC19jZXBoZXNfc2lucwtfY2VwaGVzX2Nvc3QOX2NlcGhlc19yYWRpYW51Dl9jZXBoZXNfc2luY29zdg1fY2VwaGVzX3NpbmRndw1fY2VwaGVzX2Nvc2RneAxfY2VwaGVzX3Npbmh5Dl9jZXBoZXNfc3BlbmNleg1fY2VwaGVzX3N0ZHRyew5fY2VwaGVzX3N0ZHRyaXwNX2NlcGhlc19vbmVmMn0PX2NlcGhlc190aHJlZWYwfg5fY2VwaGVzX3N0cnV2ZX8KX2NlcGhlc195doABC19jZXBoZXNfdGFugQEHX3RhbmNvdIIBC19jZXBoZXNfY290gwENX2NlcGhlc190YW5kZ4QBC190YW5jb3RfMjI0hQENX2NlcGhlc19jb3RkZ4YBDF9jZXBoZXNfdGFuaIcBDV9jZXBoZXNfbG9nMXCIAQ1fY2VwaGVzX2V4cG0xiQENX2NlcGhlc19jb3NtMYoBCl9jZXBoZXNfeW6LAQxfY2VwaGVzX3pldGGMAQ1fY2VwaGVzX3pldGFjjQEHX21hbGxvY44BBV9mcmVljwELcnVuUG9zdFNldHM=","base64");

var CephesWrapper =
/*#__PURE__*/
function () {
  function CephesWrapper(sync) {
    var _this = this;

    (0, _classCallCheck2.default)(this, CephesWrapper);
    // Initialize the runtime's memory
    this._wasmMemory = new WebAssembly.Memory({
      'initial': TOTAL_MEMORY / WASM_PAGE_SIZE,
      'maximum': TOTAL_MEMORY / WASM_PAGE_SIZE
    });
    this._HEAP8 = new Int8Array(this._wasmMemory.buffer);
    this._HEAP16 = new Int16Array(this._wasmMemory.buffer);
    this._HEAP32 = new Int32Array(this._wasmMemory.buffer);
    this._HEAPF32 = new Float32Array(this._wasmMemory.buffer);
    this._HEAPF64 = new Float64Array(this._wasmMemory.buffer); // Compile and export program

    if (sync) {
      // compile synchronously
      var program = this._compileSync();

      this._exportProgram(program); // create a dummy compile promise


      this.compiled = Promise.resolve();
    } else {
      // create a singleton compile promise
      this.compiled = this._compileAsync().then(function (program) {
        return _this._exportProgram(program);
      });
    }
  }

  (0, _createClass2.default)(CephesWrapper, [{
    key: "_AsciiToString",
    value: function _AsciiToString(ptr) {
      var str = '';

      while (1) {
        var ch = this._HEAP8[ptr++ >> 0];
        if (ch === 0) return str;
        str += String.fromCharCode(ch);
      }
    }
  }, {
    key: "_mtherr",
    value: function _mtherr(name
    /* char* */
    , code
    /* int */
    ) {
      // from mtherr.c
      var codemsg = '';

      switch (code) {
        case 1:
          codemsg = 'argument domain error';
          break;

        case 2:
          codemsg = 'function singularity';
          break;

        case 3:
          codemsg = 'overflow range error';
          break;

        case 4:
          codemsg = 'underflow range error';
          break;

        case 5:
          codemsg = 'total loss of precision';
          break;

        case 6:
          codemsg = 'partial loss of precision';
          break;

        case 33:
          codemsg = 'Unix domain error code';
          break;

        case 34:
          codemsg = 'Unix range error code';
          break;

        default:
          codemsg = 'unknown error';
      }

      var fnname = this._AsciiToString(name);

      var message = 'cephes reports "' + codemsg + '" in ' + fnname; // Restore stack to the STACKTOP before throwing. This only works because
      // all the exported cephes functions are plain functions.

      this.stackRestore(0);

      if (code == 1) {
        throw new RangeError(message);
      } else {
        throw new Error(message);
      }
    }
  }, {
    key: "_wasmImports",
    value: function _wasmImports() {
      return {
        'env': {
          // cephes error handler
          "_mtherr": this._mtherr.bind(this),
          // memory
          "memory": this._wasmMemory,
          "STACKTOP": 0,
          "STACK_MAX": TOTAL_STACK
        }
      };
    }
  }, {
    key: "_compileSync",
    value: function _compileSync() {
      return new WebAssembly.Instance(new WebAssembly.Module(WASM_CODE), this._wasmImports());
    }
  }, {
    key: "_compileAsync",
    value: function _compileAsync() {
      return WebAssembly.instantiate(WASM_CODE, this._wasmImports()).then(function (results) {
        return results.instance;
      });
    }
  }, {
    key: "_exportProgram",
    value: function _exportProgram(program) {
      // export cephes functions
      var _arr = Object.keys(program.exports);

      for (var _i = 0; _i < _arr.length; _i++) {
        var key = _arr[_i];

        if (key.startsWith('_cephes_')) {
          this[key] = program.exports[key];
        }
      } // export special stack functions


      this.stackAlloc = program.exports.stackAlloc;
      this.stackRestore = program.exports.stackRestore;
      this.stackSave = program.exports.stackSave;
    } // export helper functions

  }, {
    key: "getValue",
    value: function getValue(ptr, type) {
      type = type || 'i8';
      if (type.charAt(type.length - 1) === '*') type = 'i32'; // pointers are 32-bit

      switch (type) {
        case 'i1':
          return this._HEAP8[ptr >> 0];

        case 'i8':
          return this._HEAP8[ptr >> 0];

        case 'i16':
          return this._HEAP16[ptr >> 1];

        case 'i32':
          return this._HEAP32[ptr >> 2];

        case 'i64':
          return this._HEAP32[ptr >> 2];

        case 'float':
          return this._HEAPF32[ptr >> 2];

        case 'double':
          return this._HEAPF64[ptr >> 3];

        default:
          throw new Error('invalid type for getValue: ' + type);
      }

      return null;
    }
  }, {
    key: "writeArrayToMemory",
    value: function writeArrayToMemory(array, buffer) {
      this._HEAP8.set(array, buffer);
    }
  }]);
  return CephesWrapper;
}();

module.exports = CephesWrapper;

}).call(this,require("buffer").Buffer)
},{"@babel/runtime/helpers/classCallCheck":13,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/interopRequireDefault":17,"buffer":44}],8:[function(require,module,exports){
"use strict";

var cephes = require('./cephes.js'); // Export compiled promise, in Node.js this is just a dummy promise as the
// WebAssembly program will be compiled synchronously. It takes about 20ms
// as of Node.js v10.6.1.


exports.compiled = cephes.compiled; // from cephes/isnan.c

exports.signbit = function signbit(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: int

  var fn_ret = cephes._cephes_signbit(carg_x) | 0; // No pointers, so just return fn_ret

  var ret = fn_ret;
  return ret;
}; // from cephes/isnan.c


exports.isnan = function isnan(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: int

  var fn_ret = cephes._cephes_isnan(carg_x) | 0; // No pointers, so just return fn_ret

  var ret = fn_ret;
  return ret;
}; // from cephes/isnan.c


exports.isfinite = function isfinite(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: int

  var fn_ret = cephes._cephes_isfinite(carg_x) | 0; // No pointers, so just return fn_ret

  var ret = fn_ret;
  return ret;
}; // from cephes/cbrt.c


exports.cbrt = function cbrt(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_cbrt(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/polevl.c


exports.polevl = function polevl(
/* double */
x,
/* double[] */
coef,
/* int */
N) {
  //Save the STACKTOP because the following code will do some stack allocs
  var stacktop = cephes.stackSave(); // argument: double x

  if (typeof x !== 'number') {
    cephes.stackRestore(stacktop);
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // argument: double[] coef

  if (!(coef instanceof Float64Array)) {
    cephes.stackRestore(stacktop);
    throw new TypeError('coef must be either a Float64Array');
  }

  var carg_coef = cephes.stackAlloc(coef.length << 3);
  cephes.writeArrayToMemory(new Uint8Array(coef.buffer, coef.byteOffset, coef.byteLength), carg_coef); // argument: int N

  if (typeof N !== 'number') {
    cephes.stackRestore(stacktop);
    throw new TypeError('N must be a number');
  }

  var carg_N = N | 0; // return: double

  var fn_ret = cephes._cephes_polevl(carg_x, carg_coef, carg_N); // No pointers, so just return fn_ret


  var ret = fn_ret; // Restore internal stacktop before returning

  cephes.stackRestore(stacktop);
  return ret;
}; // from cephes/chbevl.c


exports.chbevl = function chbevl(
/* double */
x,
/* double[] */
array,
/* int */
n) {
  //Save the STACKTOP because the following code will do some stack allocs
  var stacktop = cephes.stackSave(); // argument: double x

  if (typeof x !== 'number') {
    cephes.stackRestore(stacktop);
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // argument: double[] array

  if (!(array instanceof Float64Array)) {
    cephes.stackRestore(stacktop);
    throw new TypeError('array must be either a Float64Array');
  }

  var carg_array = cephes.stackAlloc(array.length << 3);
  cephes.writeArrayToMemory(new Uint8Array(array.buffer, array.byteOffset, array.byteLength), carg_array); // argument: int n

  if (typeof n !== 'number') {
    cephes.stackRestore(stacktop);
    throw new TypeError('n must be a number');
  }

  var carg_n = n | 0; // return: double

  var fn_ret = cephes._cephes_chbevl(carg_x, carg_array, carg_n); // No pointers, so just return fn_ret


  var ret = fn_ret; // Restore internal stacktop before returning

  cephes.stackRestore(stacktop);
  return ret;
}; // from cephes/round.c


exports.round = function round(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_round(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/floor.c


exports.frexp = function frexp(
/* double */
x) {
  //Save the STACKTOP because the following code will do some stack allocs
  var stacktop = cephes.stackSave(); // argument: double x

  if (typeof x !== 'number') {
    cephes.stackRestore(stacktop);
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // argument: int* pw2

  var carg_pw2 = cephes.stackAlloc(4); // No need to zero-set it.
  // return: double

  var fn_ret = cephes._cephes_frexp(carg_x, carg_pw2); // There are pointers, so return the values of thoese too


  var ret = [fn_ret, {
    'pw2': cephes.getValue(carg_pw2, 'i32')
  }]; // Restore internal stacktop before returning

  cephes.stackRestore(stacktop);
  return ret;
}; // from cephes/floor.c


exports.ldexp = function ldexp(
/* double */
x,
/* int */
pw2) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // argument: int pw2

  if (typeof pw2 !== 'number') {
    throw new TypeError('pw2 must be a number');
  }

  var carg_pw2 = pw2 | 0; // return: double

  var fn_ret = cephes._cephes_ldexp(carg_x, carg_pw2); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/expx2.c


exports.expx2 = function expx2(
/* double */
x,
/* int */
sign) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // argument: int sign

  if (typeof sign !== 'number') {
    throw new TypeError('sign must be a number');
  }

  var carg_sign = sign | 0; // return: double

  var fn_ret = cephes._cephes_expx2(carg_x, carg_sign); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/sin.c


exports.radian = function radian(
/* double */
d,
/* double */
m,
/* double */
s) {
  // argument: double d
  if (typeof d !== 'number') {
    throw new TypeError('d must be a number');
  }

  var carg_d = d; // argument: double m

  if (typeof m !== 'number') {
    throw new TypeError('m must be a number');
  }

  var carg_m = m; // argument: double s

  if (typeof s !== 'number') {
    throw new TypeError('s must be a number');
  }

  var carg_s = s; // return: double

  var fn_ret = cephes._cephes_radian(carg_d, carg_m, carg_s); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/sincos.c


exports.sincos = function sincos(
/* double */
x,
/* int */
flg) {
  //Save the STACKTOP because the following code will do some stack allocs
  var stacktop = cephes.stackSave(); // argument: double x

  if (typeof x !== 'number') {
    cephes.stackRestore(stacktop);
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // argument: double* s

  var carg_s = cephes.stackAlloc(8); // No need to zero-set it.
  // argument: double* c

  var carg_c = cephes.stackAlloc(8); // No need to zero-set it.
  // argument: int flg

  if (typeof flg !== 'number') {
    cephes.stackRestore(stacktop);
    throw new TypeError('flg must be a number');
  }

  var carg_flg = flg | 0; // return: int

  var fn_ret = cephes._cephes_sincos(carg_x, carg_s, carg_c, carg_flg) | 0; // There are pointers, so return the values of thoese too

  var ret = [fn_ret, {
    's': cephes.getValue(carg_s, 'double'),
    'c': cephes.getValue(carg_c, 'double')
  }]; // Restore internal stacktop before returning

  cephes.stackRestore(stacktop);
  return ret;
}; // from cephes/tan.c


exports.cot = function cot(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_cot(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/tandg.c


exports.cotdg = function cotdg(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_cotdg(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/unity.c


exports.log1p = function log1p(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_log1p(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/unity.c


exports.expm1 = function expm1(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_expm1(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/unity.c


exports.cosm1 = function cosm1(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_cosm1(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/asin.c


exports.acos = function acos(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_acos(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/acosh.c


exports.acosh = function acosh(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_acosh(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/asinh.c


exports.asinh = function asinh(
/* double */
xx) {
  // argument: double xx
  if (typeof xx !== 'number') {
    throw new TypeError('xx must be a number');
  }

  var carg_xx = xx; // return: double

  var fn_ret = cephes._cephes_asinh(carg_xx); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/atanh.c


exports.atanh = function atanh(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_atanh(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/asin.c


exports.asin = function asin(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_asin(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/atan.c


exports.atan = function atan(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_atan(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/atan.c


exports.atan2 = function atan2(
/* double */
y,
/* double */
x) {
  // argument: double y
  if (typeof y !== 'number') {
    throw new TypeError('y must be a number');
  }

  var carg_y = y; // argument: double x

  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_atan2(carg_y, carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/sin.c


exports.cos = function cos(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_cos(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/sindg.c


exports.cosdg = function cosdg(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_cosdg(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/exp.c


exports.exp = function exp(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_exp(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/exp2.c


exports.exp2 = function exp2(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_exp2(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/exp10.c


exports.exp10 = function exp10(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_exp10(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/cosh.c


exports.cosh = function cosh(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_cosh(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/sinh.c


exports.sinh = function sinh(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_sinh(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/tanh.c


exports.tanh = function tanh(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_tanh(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/log.c


exports.log = function log(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_log(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/log2.c


exports.log2 = function log2(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_log2(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/log10.c


exports.log10 = function log10(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_log10(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/pow.c


exports.pow = function pow(
/* double */
x,
/* double */
y) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // argument: double y

  if (typeof y !== 'number') {
    throw new TypeError('y must be a number');
  }

  var carg_y = y; // return: double

  var fn_ret = cephes._cephes_pow(carg_x, carg_y); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/powi.c


exports.powi = function powi(
/* double */
x,
/* int */
nn) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // argument: int nn

  if (typeof nn !== 'number') {
    throw new TypeError('nn must be a number');
  }

  var carg_nn = nn | 0; // return: double

  var fn_ret = cephes._cephes_powi(carg_x, carg_nn); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/sin.c


exports.sin = function sin(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_sin(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/sindg.c


exports.sindg = function sindg(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_sindg(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/tan.c


exports.tan = function tan(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_tan(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/tandg.c


exports.tandg = function tandg(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_tandg(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/ei.c


exports.ei = function ei(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_ei(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/expn.c


exports.expn = function expn(
/* int */
n,
/* double */
x) {
  // argument: int n
  if (typeof n !== 'number') {
    throw new TypeError('n must be a number');
  }

  var carg_n = n | 0; // argument: double x

  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_expn(carg_n, carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/shichi.c


exports.shichi = function shichi(
/* double */
x) {
  //Save the STACKTOP because the following code will do some stack allocs
  var stacktop = cephes.stackSave(); // argument: double x

  if (typeof x !== 'number') {
    cephes.stackRestore(stacktop);
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // argument: double* si

  var carg_si = cephes.stackAlloc(8); // No need to zero-set it.
  // argument: double* ci

  var carg_ci = cephes.stackAlloc(8); // No need to zero-set it.
  // return: int

  var fn_ret = cephes._cephes_shichi(carg_x, carg_si, carg_ci) | 0; // There are pointers, so return the values of thoese too

  var ret = [fn_ret, {
    'si': cephes.getValue(carg_si, 'double'),
    'ci': cephes.getValue(carg_ci, 'double')
  }]; // Restore internal stacktop before returning

  cephes.stackRestore(stacktop);
  return ret;
}; // from cephes/sici.c


exports.sici = function sici(
/* double */
x) {
  //Save the STACKTOP because the following code will do some stack allocs
  var stacktop = cephes.stackSave(); // argument: double x

  if (typeof x !== 'number') {
    cephes.stackRestore(stacktop);
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // argument: double* si

  var carg_si = cephes.stackAlloc(8); // No need to zero-set it.
  // argument: double* ci

  var carg_ci = cephes.stackAlloc(8); // No need to zero-set it.
  // return: int

  var fn_ret = cephes._cephes_sici(carg_x, carg_si, carg_ci) | 0; // There are pointers, so return the values of thoese too

  var ret = [fn_ret, {
    'si': cephes.getValue(carg_si, 'double'),
    'ci': cephes.getValue(carg_ci, 'double')
  }]; // Restore internal stacktop before returning

  cephes.stackRestore(stacktop);
  return ret;
}; // from cephes/beta.c


exports.lbeta = function lbeta(
/* double */
a,
/* double */
b) {
  // argument: double a
  if (typeof a !== 'number') {
    throw new TypeError('a must be a number');
  }

  var carg_a = a; // argument: double b

  if (typeof b !== 'number') {
    throw new TypeError('b must be a number');
  }

  var carg_b = b; // return: double

  var fn_ret = cephes._cephes_lbeta(carg_a, carg_b); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/beta.c


exports.beta = function beta(
/* double */
a,
/* double */
b) {
  // argument: double a
  if (typeof a !== 'number') {
    throw new TypeError('a must be a number');
  }

  var carg_a = a; // argument: double b

  if (typeof b !== 'number') {
    throw new TypeError('b must be a number');
  }

  var carg_b = b; // return: double

  var fn_ret = cephes._cephes_beta(carg_a, carg_b); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/fac.c


exports.fac = function fac(
/* int */
i) {
  // argument: int i
  if (typeof i !== 'number') {
    throw new TypeError('i must be a number');
  }

  var carg_i = i | 0; // return: double

  var fn_ret = cephes._cephes_fac(carg_i); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/gamma.c


exports.gamma = function gamma(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_gamma(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/gamma.c


exports.lgam = function lgam(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_lgam(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/incbet.c


exports.incbet = function incbet(
/* double */
aa,
/* double */
bb,
/* double */
xx) {
  // argument: double aa
  if (typeof aa !== 'number') {
    throw new TypeError('aa must be a number');
  }

  var carg_aa = aa; // argument: double bb

  if (typeof bb !== 'number') {
    throw new TypeError('bb must be a number');
  }

  var carg_bb = bb; // argument: double xx

  if (typeof xx !== 'number') {
    throw new TypeError('xx must be a number');
  }

  var carg_xx = xx; // return: double

  var fn_ret = cephes._cephes_incbet(carg_aa, carg_bb, carg_xx); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/incbi.c


exports.incbi = function incbi(
/* double */
aa,
/* double */
bb,
/* double */
yy0) {
  // argument: double aa
  if (typeof aa !== 'number') {
    throw new TypeError('aa must be a number');
  }

  var carg_aa = aa; // argument: double bb

  if (typeof bb !== 'number') {
    throw new TypeError('bb must be a number');
  }

  var carg_bb = bb; // argument: double yy0

  if (typeof yy0 !== 'number') {
    throw new TypeError('yy0 must be a number');
  }

  var carg_yy0 = yy0; // return: double

  var fn_ret = cephes._cephes_incbi(carg_aa, carg_bb, carg_yy0); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/igam.c


exports.igam = function igam(
/* double */
a,
/* double */
x) {
  // argument: double a
  if (typeof a !== 'number') {
    throw new TypeError('a must be a number');
  }

  var carg_a = a; // argument: double x

  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_igam(carg_a, carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/igam.c


exports.igamc = function igamc(
/* double */
a,
/* double */
x) {
  // argument: double a
  if (typeof a !== 'number') {
    throw new TypeError('a must be a number');
  }

  var carg_a = a; // argument: double x

  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_igamc(carg_a, carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/igami.c


exports.igami = function igami(
/* double */
a,
/* double */
y0) {
  // argument: double a
  if (typeof a !== 'number') {
    throw new TypeError('a must be a number');
  }

  var carg_a = a; // argument: double y0

  if (typeof y0 !== 'number') {
    throw new TypeError('y0 must be a number');
  }

  var carg_y0 = y0; // return: double

  var fn_ret = cephes._cephes_igami(carg_a, carg_y0); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/psi.c


exports.psi = function psi(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_psi(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/rgamma.c


exports.rgamma = function rgamma(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_rgamma(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/ndtr.c


exports.erf = function erf(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_erf(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/ndtr.c


exports.erfc = function erfc(
/* double */
a) {
  // argument: double a
  if (typeof a !== 'number') {
    throw new TypeError('a must be a number');
  }

  var carg_a = a; // return: double

  var fn_ret = cephes._cephes_erfc(carg_a); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/dawsn.c


exports.dawsn = function dawsn(
/* double */
xx) {
  // argument: double xx
  if (typeof xx !== 'number') {
    throw new TypeError('xx must be a number');
  }

  var carg_xx = xx; // return: double

  var fn_ret = cephes._cephes_dawsn(carg_xx); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/fresnl.c


exports.fresnl = function fresnl(
/* double */
xxa) {
  //Save the STACKTOP because the following code will do some stack allocs
  var stacktop = cephes.stackSave(); // argument: double xxa

  if (typeof xxa !== 'number') {
    cephes.stackRestore(stacktop);
    throw new TypeError('xxa must be a number');
  }

  var carg_xxa = xxa; // argument: double* ssa

  var carg_ssa = cephes.stackAlloc(8); // No need to zero-set it.
  // argument: double* cca

  var carg_cca = cephes.stackAlloc(8); // No need to zero-set it.
  // return: int

  var fn_ret = cephes._cephes_fresnl(carg_xxa, carg_ssa, carg_cca) | 0; // There are pointers, so return the values of thoese too

  var ret = [fn_ret, {
    'ssa': cephes.getValue(carg_ssa, 'double'),
    'cca': cephes.getValue(carg_cca, 'double')
  }]; // Restore internal stacktop before returning

  cephes.stackRestore(stacktop);
  return ret;
}; // from cephes/airy.c


exports.airy = function airy(
/* double */
x) {
  //Save the STACKTOP because the following code will do some stack allocs
  var stacktop = cephes.stackSave(); // argument: double x

  if (typeof x !== 'number') {
    cephes.stackRestore(stacktop);
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // argument: double* ai

  var carg_ai = cephes.stackAlloc(8); // No need to zero-set it.
  // argument: double* aip

  var carg_aip = cephes.stackAlloc(8); // No need to zero-set it.
  // argument: double* bi

  var carg_bi = cephes.stackAlloc(8); // No need to zero-set it.
  // argument: double* bip

  var carg_bip = cephes.stackAlloc(8); // No need to zero-set it.
  // return: int

  var fn_ret = cephes._cephes_airy(carg_x, carg_ai, carg_aip, carg_bi, carg_bip) | 0; // There are pointers, so return the values of thoese too

  var ret = [fn_ret, {
    'ai': cephes.getValue(carg_ai, 'double'),
    'aip': cephes.getValue(carg_aip, 'double'),
    'bi': cephes.getValue(carg_bi, 'double'),
    'bip': cephes.getValue(carg_bip, 'double')
  }]; // Restore internal stacktop before returning

  cephes.stackRestore(stacktop);
  return ret;
}; // from cephes/j0.c


exports.j0 = function j0(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_j0(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/j1.c


exports.j1 = function j1(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_j1(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/jn.c


exports.jn = function jn(
/* int */
n,
/* double */
x) {
  // argument: int n
  if (typeof n !== 'number') {
    throw new TypeError('n must be a number');
  }

  var carg_n = n | 0; // argument: double x

  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_jn(carg_n, carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/jv.c


exports.jv = function jv(
/* double */
n,
/* double */
x) {
  // argument: double n
  if (typeof n !== 'number') {
    throw new TypeError('n must be a number');
  }

  var carg_n = n; // argument: double x

  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_jv(carg_n, carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/j0.c


exports.y0 = function y0(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_y0(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/j1.c


exports.y1 = function y1(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_y1(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/yn.c


exports.yn = function yn(
/* int */
n,
/* double */
x) {
  // argument: int n
  if (typeof n !== 'number') {
    throw new TypeError('n must be a number');
  }

  var carg_n = n | 0; // argument: double x

  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_yn(carg_n, carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/struve.c


exports.yv = function yv(
/* double */
v,
/* double */
x) {
  // argument: double v
  if (typeof v !== 'number') {
    throw new TypeError('v must be a number');
  }

  var carg_v = v; // argument: double x

  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_yv(carg_v, carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/i0.c


exports.i0 = function i0(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_i0(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/i0.c


exports.i0e = function i0e(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_i0e(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/i1.c


exports.i1 = function i1(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_i1(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/i1.c


exports.i1e = function i1e(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_i1e(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/iv.c


exports.iv = function iv(
/* double */
v,
/* double */
x) {
  // argument: double v
  if (typeof v !== 'number') {
    throw new TypeError('v must be a number');
  }

  var carg_v = v; // argument: double x

  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_iv(carg_v, carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/k0.c


exports.k0 = function k0(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_k0(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/k0.c


exports.k0e = function k0e(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_k0e(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/k1.c


exports.k1 = function k1(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_k1(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/k1.c


exports.k1e = function k1e(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_k1e(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/kn.c


exports.kn = function kn(
/* int */
nn,
/* double */
x) {
  // argument: int nn
  if (typeof nn !== 'number') {
    throw new TypeError('nn must be a number');
  }

  var carg_nn = nn | 0; // argument: double x

  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_kn(carg_nn, carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/hyperg.c


exports.hyperg = function hyperg(
/* double */
a,
/* double */
b,
/* double */
x) {
  // argument: double a
  if (typeof a !== 'number') {
    throw new TypeError('a must be a number');
  }

  var carg_a = a; // argument: double b

  if (typeof b !== 'number') {
    throw new TypeError('b must be a number');
  }

  var carg_b = b; // argument: double x

  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_hyperg(carg_a, carg_b, carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/hyp2f1.c


exports.hyp2f1 = function hyp2f1(
/* double */
a,
/* double */
b,
/* double */
c,
/* double */
x) {
  // argument: double a
  if (typeof a !== 'number') {
    throw new TypeError('a must be a number');
  }

  var carg_a = a; // argument: double b

  if (typeof b !== 'number') {
    throw new TypeError('b must be a number');
  }

  var carg_b = b; // argument: double c

  if (typeof c !== 'number') {
    throw new TypeError('c must be a number');
  }

  var carg_c = c; // argument: double x

  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_hyp2f1(carg_a, carg_b, carg_c, carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/ellpe.c


exports.ellpe = function ellpe(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_ellpe(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/ellie.c


exports.ellie = function ellie(
/* double */
phi,
/* double */
m) {
  // argument: double phi
  if (typeof phi !== 'number') {
    throw new TypeError('phi must be a number');
  }

  var carg_phi = phi; // argument: double m

  if (typeof m !== 'number') {
    throw new TypeError('m must be a number');
  }

  var carg_m = m; // return: double

  var fn_ret = cephes._cephes_ellie(carg_phi, carg_m); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/ellpk.c


exports.ellpk = function ellpk(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_ellpk(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/ellik.c


exports.ellik = function ellik(
/* double */
phi,
/* double */
m) {
  // argument: double phi
  if (typeof phi !== 'number') {
    throw new TypeError('phi must be a number');
  }

  var carg_phi = phi; // argument: double m

  if (typeof m !== 'number') {
    throw new TypeError('m must be a number');
  }

  var carg_m = m; // return: double

  var fn_ret = cephes._cephes_ellik(carg_phi, carg_m); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/ellpj.c


exports.ellpj = function ellpj(
/* double */
u,
/* double */
m) {
  //Save the STACKTOP because the following code will do some stack allocs
  var stacktop = cephes.stackSave(); // argument: double u

  if (typeof u !== 'number') {
    cephes.stackRestore(stacktop);
    throw new TypeError('u must be a number');
  }

  var carg_u = u; // argument: double m

  if (typeof m !== 'number') {
    cephes.stackRestore(stacktop);
    throw new TypeError('m must be a number');
  }

  var carg_m = m; // argument: double* sn

  var carg_sn = cephes.stackAlloc(8); // No need to zero-set it.
  // argument: double* cn

  var carg_cn = cephes.stackAlloc(8); // No need to zero-set it.
  // argument: double* dn

  var carg_dn = cephes.stackAlloc(8); // No need to zero-set it.
  // argument: double* ph

  var carg_ph = cephes.stackAlloc(8); // No need to zero-set it.
  // return: int

  var fn_ret = cephes._cephes_ellpj(carg_u, carg_m, carg_sn, carg_cn, carg_dn, carg_ph) | 0; // There are pointers, so return the values of thoese too

  var ret = [fn_ret, {
    'sn': cephes.getValue(carg_sn, 'double'),
    'cn': cephes.getValue(carg_cn, 'double'),
    'dn': cephes.getValue(carg_dn, 'double'),
    'ph': cephes.getValue(carg_ph, 'double')
  }]; // Restore internal stacktop before returning

  cephes.stackRestore(stacktop);
  return ret;
}; // from cephes/btdtr.c


exports.btdtr = function btdtr(
/* double */
a,
/* double */
b,
/* double */
x) {
  // argument: double a
  if (typeof a !== 'number') {
    throw new TypeError('a must be a number');
  }

  var carg_a = a; // argument: double b

  if (typeof b !== 'number') {
    throw new TypeError('b must be a number');
  }

  var carg_b = b; // argument: double x

  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_btdtr(carg_a, carg_b, carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/kolmogorov.c


exports.smirnov = function smirnov(
/* int */
n,
/* double */
e) {
  // argument: int n
  if (typeof n !== 'number') {
    throw new TypeError('n must be a number');
  }

  var carg_n = n | 0; // argument: double e

  if (typeof e !== 'number') {
    throw new TypeError('e must be a number');
  }

  var carg_e = e; // return: double

  var fn_ret = cephes._cephes_smirnov(carg_n, carg_e); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/kolmogorov.c


exports.kolmogorov = function kolmogorov(
/* double */
y) {
  // argument: double y
  if (typeof y !== 'number') {
    throw new TypeError('y must be a number');
  }

  var carg_y = y; // return: double

  var fn_ret = cephes._cephes_kolmogorov(carg_y); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/kolmogorov.c


exports.smirnovi = function smirnovi(
/* int */
n,
/* double */
p) {
  // argument: int n
  if (typeof n !== 'number') {
    throw new TypeError('n must be a number');
  }

  var carg_n = n | 0; // argument: double p

  if (typeof p !== 'number') {
    throw new TypeError('p must be a number');
  }

  var carg_p = p; // return: double

  var fn_ret = cephes._cephes_smirnovi(carg_n, carg_p); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/kolmogorov.c


exports.kolmogi = function kolmogi(
/* double */
p) {
  // argument: double p
  if (typeof p !== 'number') {
    throw new TypeError('p must be a number');
  }

  var carg_p = p; // return: double

  var fn_ret = cephes._cephes_kolmogi(carg_p); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/nbdtr.c


exports.nbdtri = function nbdtri(
/* int */
k,
/* int */
n,
/* double */
p) {
  // argument: int k
  if (typeof k !== 'number') {
    throw new TypeError('k must be a number');
  }

  var carg_k = k | 0; // argument: int n

  if (typeof n !== 'number') {
    throw new TypeError('n must be a number');
  }

  var carg_n = n | 0; // argument: double p

  if (typeof p !== 'number') {
    throw new TypeError('p must be a number');
  }

  var carg_p = p; // return: double

  var fn_ret = cephes._cephes_nbdtri(carg_k, carg_n, carg_p); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/stdtr.c


exports.stdtri = function stdtri(
/* int */
k,
/* double */
p) {
  // argument: int k
  if (typeof k !== 'number') {
    throw new TypeError('k must be a number');
  }

  var carg_k = k | 0; // argument: double p

  if (typeof p !== 'number') {
    throw new TypeError('p must be a number');
  }

  var carg_p = p; // return: double

  var fn_ret = cephes._cephes_stdtri(carg_k, carg_p); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/bdtr.c


exports.bdtr = function bdtr(
/* int */
k,
/* int */
n,
/* double */
p) {
  // argument: int k
  if (typeof k !== 'number') {
    throw new TypeError('k must be a number');
  }

  var carg_k = k | 0; // argument: int n

  if (typeof n !== 'number') {
    throw new TypeError('n must be a number');
  }

  var carg_n = n | 0; // argument: double p

  if (typeof p !== 'number') {
    throw new TypeError('p must be a number');
  }

  var carg_p = p; // return: double

  var fn_ret = cephes._cephes_bdtr(carg_k, carg_n, carg_p); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/bdtr.c


exports.bdtrc = function bdtrc(
/* int */
k,
/* int */
n,
/* double */
p) {
  // argument: int k
  if (typeof k !== 'number') {
    throw new TypeError('k must be a number');
  }

  var carg_k = k | 0; // argument: int n

  if (typeof n !== 'number') {
    throw new TypeError('n must be a number');
  }

  var carg_n = n | 0; // argument: double p

  if (typeof p !== 'number') {
    throw new TypeError('p must be a number');
  }

  var carg_p = p; // return: double

  var fn_ret = cephes._cephes_bdtrc(carg_k, carg_n, carg_p); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/bdtr.c


exports.bdtri = function bdtri(
/* int */
k,
/* int */
n,
/* double */
y) {
  // argument: int k
  if (typeof k !== 'number') {
    throw new TypeError('k must be a number');
  }

  var carg_k = k | 0; // argument: int n

  if (typeof n !== 'number') {
    throw new TypeError('n must be a number');
  }

  var carg_n = n | 0; // argument: double y

  if (typeof y !== 'number') {
    throw new TypeError('y must be a number');
  }

  var carg_y = y; // return: double

  var fn_ret = cephes._cephes_bdtri(carg_k, carg_n, carg_y); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/chdtr.c


exports.chdtr = function chdtr(
/* double */
df,
/* double */
x) {
  // argument: double df
  if (typeof df !== 'number') {
    throw new TypeError('df must be a number');
  }

  var carg_df = df; // argument: double x

  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_chdtr(carg_df, carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/chdtr.c


exports.chdtrc = function chdtrc(
/* double */
df,
/* double */
x) {
  // argument: double df
  if (typeof df !== 'number') {
    throw new TypeError('df must be a number');
  }

  var carg_df = df; // argument: double x

  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_chdtrc(carg_df, carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/chdtr.c


exports.chdtri = function chdtri(
/* double */
df,
/* double */
y) {
  // argument: double df
  if (typeof df !== 'number') {
    throw new TypeError('df must be a number');
  }

  var carg_df = df; // argument: double y

  if (typeof y !== 'number') {
    throw new TypeError('y must be a number');
  }

  var carg_y = y; // return: double

  var fn_ret = cephes._cephes_chdtri(carg_df, carg_y); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/fdtr.c


exports.fdtr = function fdtr(
/* int */
ia,
/* int */
ib,
/* double */
x) {
  // argument: int ia
  if (typeof ia !== 'number') {
    throw new TypeError('ia must be a number');
  }

  var carg_ia = ia | 0; // argument: int ib

  if (typeof ib !== 'number') {
    throw new TypeError('ib must be a number');
  }

  var carg_ib = ib | 0; // argument: double x

  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_fdtr(carg_ia, carg_ib, carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/fdtr.c


exports.fdtrc = function fdtrc(
/* int */
ia,
/* int */
ib,
/* double */
x) {
  // argument: int ia
  if (typeof ia !== 'number') {
    throw new TypeError('ia must be a number');
  }

  var carg_ia = ia | 0; // argument: int ib

  if (typeof ib !== 'number') {
    throw new TypeError('ib must be a number');
  }

  var carg_ib = ib | 0; // argument: double x

  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_fdtrc(carg_ia, carg_ib, carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/fdtr.c


exports.fdtri = function fdtri(
/* int */
ia,
/* int */
ib,
/* double */
y) {
  // argument: int ia
  if (typeof ia !== 'number') {
    throw new TypeError('ia must be a number');
  }

  var carg_ia = ia | 0; // argument: int ib

  if (typeof ib !== 'number') {
    throw new TypeError('ib must be a number');
  }

  var carg_ib = ib | 0; // argument: double y

  if (typeof y !== 'number') {
    throw new TypeError('y must be a number');
  }

  var carg_y = y; // return: double

  var fn_ret = cephes._cephes_fdtri(carg_ia, carg_ib, carg_y); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/gdtr.c


exports.gdtr = function gdtr(
/* double */
a,
/* double */
b,
/* double */
x) {
  // argument: double a
  if (typeof a !== 'number') {
    throw new TypeError('a must be a number');
  }

  var carg_a = a; // argument: double b

  if (typeof b !== 'number') {
    throw new TypeError('b must be a number');
  }

  var carg_b = b; // argument: double x

  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_gdtr(carg_a, carg_b, carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/gdtr.c


exports.gdtrc = function gdtrc(
/* double */
a,
/* double */
b,
/* double */
x) {
  // argument: double a
  if (typeof a !== 'number') {
    throw new TypeError('a must be a number');
  }

  var carg_a = a; // argument: double b

  if (typeof b !== 'number') {
    throw new TypeError('b must be a number');
  }

  var carg_b = b; // argument: double x

  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_gdtrc(carg_a, carg_b, carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/nbdtr.c


exports.nbdtr = function nbdtr(
/* int */
k,
/* int */
n,
/* double */
p) {
  // argument: int k
  if (typeof k !== 'number') {
    throw new TypeError('k must be a number');
  }

  var carg_k = k | 0; // argument: int n

  if (typeof n !== 'number') {
    throw new TypeError('n must be a number');
  }

  var carg_n = n | 0; // argument: double p

  if (typeof p !== 'number') {
    throw new TypeError('p must be a number');
  }

  var carg_p = p; // return: double

  var fn_ret = cephes._cephes_nbdtr(carg_k, carg_n, carg_p); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/nbdtr.c


exports.nbdtrc = function nbdtrc(
/* int */
k,
/* int */
n,
/* double */
p) {
  // argument: int k
  if (typeof k !== 'number') {
    throw new TypeError('k must be a number');
  }

  var carg_k = k | 0; // argument: int n

  if (typeof n !== 'number') {
    throw new TypeError('n must be a number');
  }

  var carg_n = n | 0; // argument: double p

  if (typeof p !== 'number') {
    throw new TypeError('p must be a number');
  }

  var carg_p = p; // return: double

  var fn_ret = cephes._cephes_nbdtrc(carg_k, carg_n, carg_p); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/ndtr.c


exports.ndtr = function ndtr(
/* double */
a) {
  // argument: double a
  if (typeof a !== 'number') {
    throw new TypeError('a must be a number');
  }

  var carg_a = a; // return: double

  var fn_ret = cephes._cephes_ndtr(carg_a); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/ndtri.c


exports.ndtri = function ndtri(
/* double */
y0) {
  // argument: double y0
  if (typeof y0 !== 'number') {
    throw new TypeError('y0 must be a number');
  }

  var carg_y0 = y0; // return: double

  var fn_ret = cephes._cephes_ndtri(carg_y0); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/pdtr.c


exports.pdtr = function pdtr(
/* int */
k,
/* double */
m) {
  // argument: int k
  if (typeof k !== 'number') {
    throw new TypeError('k must be a number');
  }

  var carg_k = k | 0; // argument: double m

  if (typeof m !== 'number') {
    throw new TypeError('m must be a number');
  }

  var carg_m = m; // return: double

  var fn_ret = cephes._cephes_pdtr(carg_k, carg_m); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/pdtr.c


exports.pdtrc = function pdtrc(
/* int */
k,
/* double */
m) {
  // argument: int k
  if (typeof k !== 'number') {
    throw new TypeError('k must be a number');
  }

  var carg_k = k | 0; // argument: double m

  if (typeof m !== 'number') {
    throw new TypeError('m must be a number');
  }

  var carg_m = m; // return: double

  var fn_ret = cephes._cephes_pdtrc(carg_k, carg_m); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/pdtr.c


exports.pdtri = function pdtri(
/* int */
k,
/* double */
y) {
  // argument: int k
  if (typeof k !== 'number') {
    throw new TypeError('k must be a number');
  }

  var carg_k = k | 0; // argument: double y

  if (typeof y !== 'number') {
    throw new TypeError('y must be a number');
  }

  var carg_y = y; // return: double

  var fn_ret = cephes._cephes_pdtri(carg_k, carg_y); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/stdtr.c


exports.stdtr = function stdtr(
/* int */
k,
/* double */
t) {
  // argument: int k
  if (typeof k !== 'number') {
    throw new TypeError('k must be a number');
  }

  var carg_k = k | 0; // argument: double t

  if (typeof t !== 'number') {
    throw new TypeError('t must be a number');
  }

  var carg_t = t; // return: double

  var fn_ret = cephes._cephes_stdtr(carg_k, carg_t); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/planck.c


exports.plancki = function plancki(
/* double */
w,
/* double */
T) {
  // argument: double w
  if (typeof w !== 'number') {
    throw new TypeError('w must be a number');
  }

  var carg_w = w; // argument: double T

  if (typeof T !== 'number') {
    throw new TypeError('T must be a number');
  }

  var carg_T = T; // return: double

  var fn_ret = cephes._cephes_plancki(carg_w, carg_T); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/planck.c


exports.planckc = function planckc(
/* double */
w,
/* double */
T) {
  // argument: double w
  if (typeof w !== 'number') {
    throw new TypeError('w must be a number');
  }

  var carg_w = w; // argument: double T

  if (typeof T !== 'number') {
    throw new TypeError('T must be a number');
  }

  var carg_T = T; // return: double

  var fn_ret = cephes._cephes_planckc(carg_w, carg_T); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/planck.c


exports.planckd = function planckd(
/* double */
w,
/* double */
T) {
  // argument: double w
  if (typeof w !== 'number') {
    throw new TypeError('w must be a number');
  }

  var carg_w = w; // argument: double T

  if (typeof T !== 'number') {
    throw new TypeError('T must be a number');
  }

  var carg_T = T; // return: double

  var fn_ret = cephes._cephes_planckd(carg_w, carg_T); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/planck.c


exports.planckw = function planckw(
/* double */
T) {
  // argument: double T
  if (typeof T !== 'number') {
    throw new TypeError('T must be a number');
  }

  var carg_T = T; // return: double

  var fn_ret = cephes._cephes_planckw(carg_T); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/spence.c


exports.spence = function spence(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_spence(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/zetac.c


exports.zetac = function zetac(
/* double */
x) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_zetac(carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/zeta.c


exports.zeta = function zeta(
/* double */
x,
/* double */
q) {
  // argument: double x
  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // argument: double q

  if (typeof q !== 'number') {
    throw new TypeError('q must be a number');
  }

  var carg_q = q; // return: double

  var fn_ret = cephes._cephes_zeta(carg_x, carg_q); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/struve.c


exports.struve = function struve(
/* double */
v,
/* double */
x) {
  // argument: double v
  if (typeof v !== 'number') {
    throw new TypeError('v must be a number');
  }

  var carg_v = v; // argument: double x

  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_struve(carg_v, carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
}; // from cephes/polevl.c


exports.p1evl = function p1evl(
/* double */
x,
/* double[] */
coef,
/* int */
N) {
  //Save the STACKTOP because the following code will do some stack allocs
  var stacktop = cephes.stackSave(); // argument: double x

  if (typeof x !== 'number') {
    cephes.stackRestore(stacktop);
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // argument: double[] coef

  if (!(coef instanceof Float64Array)) {
    cephes.stackRestore(stacktop);
    throw new TypeError('coef must be either a Float64Array');
  }

  var carg_coef = cephes.stackAlloc(coef.length << 3);
  cephes.writeArrayToMemory(new Uint8Array(coef.buffer, coef.byteOffset, coef.byteLength), carg_coef); // argument: int N

  if (typeof N !== 'number') {
    cephes.stackRestore(stacktop);
    throw new TypeError('N must be a number');
  }

  var carg_N = N | 0; // return: double

  var fn_ret = cephes._cephes_p1evl(carg_x, carg_coef, carg_N); // No pointers, so just return fn_ret


  var ret = fn_ret; // Restore internal stacktop before returning

  cephes.stackRestore(stacktop);
  return ret;
}; // from cephes/polylog.c


exports.polylog = function polylog(
/* int */
n,
/* double */
x) {
  // argument: int n
  if (typeof n !== 'number') {
    throw new TypeError('n must be a number');
  }

  var carg_n = n | 0; // argument: double x

  if (typeof x !== 'number') {
    throw new TypeError('x must be a number');
  }

  var carg_x = x; // return: double

  var fn_ret = cephes._cephes_polylog(carg_n, carg_x); // No pointers, so just return fn_ret


  var ret = fn_ret;
  return ret;
};

},{"./cephes.js":6}],9:[function(require,module,exports){
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;
},{}],10:[function(require,module,exports){
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

module.exports = _arrayWithoutHoles;
},{}],11:[function(require,module,exports){
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;
},{}],12:[function(require,module,exports){
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;
},{}],13:[function(require,module,exports){
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;
},{}],14:[function(require,module,exports){
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;
},{}],15:[function(require,module,exports){
function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;
},{}],16:[function(require,module,exports){
var setPrototypeOf = require("./setPrototypeOf");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;
},{"./setPrototypeOf":23}],17:[function(require,module,exports){
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

module.exports = _interopRequireDefault;
},{}],18:[function(require,module,exports){
function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

module.exports = _iterableToArray;
},{}],19:[function(require,module,exports){
function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;
},{}],20:[function(require,module,exports){
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

module.exports = _nonIterableRest;
},{}],21:[function(require,module,exports){
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

module.exports = _nonIterableSpread;
},{}],22:[function(require,module,exports){
var _typeof = require("../helpers/typeof");

var assertThisInitialized = require("./assertThisInitialized");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;
},{"../helpers/typeof":26,"./assertThisInitialized":11}],23:[function(require,module,exports){
function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
},{}],24:[function(require,module,exports){
var arrayWithHoles = require("./arrayWithHoles");

var iterableToArrayLimit = require("./iterableToArrayLimit");

var nonIterableRest = require("./nonIterableRest");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;
},{"./arrayWithHoles":9,"./iterableToArrayLimit":19,"./nonIterableRest":20}],25:[function(require,module,exports){
var arrayWithoutHoles = require("./arrayWithoutHoles");

var iterableToArray = require("./iterableToArray");

var nonIterableSpread = require("./nonIterableSpread");

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;
},{"./arrayWithoutHoles":10,"./iterableToArray":18,"./nonIterableSpread":21}],26:[function(require,module,exports){
function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;
},{}],27:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() {
  return this || (typeof self === "object" && self);
})() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = require("./runtime");

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}

},{"./runtime":28}],28:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() {
    return this || (typeof self === "object" && self);
  })() || Function("return this")()
);

},{}],29:[function(require,module,exports){
module.exports = require("regenerator-runtime");

},{"regenerator-runtime":27}],30:[function(require,module,exports){
// https://d3js.org/d3-array/ v1.2.4 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function bisector(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
}

function ascendingComparator(f) {
  return function(d, x) {
    return ascending(f(d), x);
  };
}

var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;

function pairs(array, f) {
  if (f == null) f = pair;
  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
  while (i < n) pairs[i] = f(p, p = array[++i]);
  return pairs;
}

function pair(a, b) {
  return [a, b];
}

function cross(values0, values1, reduce) {
  var n0 = values0.length,
      n1 = values1.length,
      values = new Array(n0 * n1),
      i0,
      i1,
      i,
      value0;

  if (reduce == null) reduce = pair;

  for (i0 = i = 0; i0 < n0; ++i0) {
    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
      values[i] = reduce(value0, values1[i1]);
    }
  }

  return values;
}

function descending(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

function number(x) {
  return x === null ? NaN : +x;
}

function variance(values, valueof) {
  var n = values.length,
      m = 0,
      i = -1,
      mean = 0,
      value,
      delta,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  if (m > 1) return sum / (m - 1);
}

function deviation(array, f) {
  var v = variance(array, f);
  return v ? Math.sqrt(v) : v;
}

function extent(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
}

var array = Array.prototype;

var slice = array.slice;
var map = array.map;

function constant(x) {
  return function() {
    return x;
  };
}

function identity(x) {
  return x;
}

function range(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}

var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

function ticks(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) ticks[i] = (start - i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
}

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

function sturges(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
}

function histogram() {
  var value = identity,
      domain = extent,
      threshold = sturges;

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      tz = tickStep(x0, x1, tz);
      tz = range(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive
    }

    // Remove any thresholds outside the domain.
    var m = tz.length;
    while (tz[0] <= x0) tz.shift(), --m;
    while (tz[m - 1] > x1) tz.pop(), --m;

    var bins = new Array(m + 1),
        bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    for (i = 0; i < n; ++i) {
      x = values[i];
      if (x0 <= x && x <= x1) {
        bins[bisectRight(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
  };

  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
  };

  return histogram;
}

function quantile(values, p, valueof) {
  if (valueof == null) valueof = number;
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}

function freedmanDiaconis(values, min, max) {
  values = map.call(values, number).sort(ascending);
  return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
}

function scott(values, min, max) {
  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
}

function max(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
}

function mean(values, valueof) {
  var n = values.length,
      m = n,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) sum += value;
      else --m;
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;
      else --m;
    }
  }

  if (m) return sum / m;
}

function median(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      numbers = [];

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) {
        numbers.push(value);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) {
        numbers.push(value);
      }
    }
  }

  return quantile(numbers.sort(ascending), 0.5);
}

function merge(arrays) {
  var n = arrays.length,
      m,
      i = -1,
      j = 0,
      merged,
      array;

  while (++i < n) j += arrays[i].length;
  merged = new Array(j);

  while (--n >= 0) {
    array = arrays[n];
    m = array.length;
    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }

  return merged;
}

function min(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  return min;
}

function permute(array, indexes) {
  var i = indexes.length, permutes = new Array(i);
  while (i--) permutes[i] = array[indexes[i]];
  return permutes;
}

function scan(values, compare) {
  if (!(n = values.length)) return;
  var n,
      i = 0,
      j = 0,
      xi,
      xj = values[j];

  if (compare == null) compare = ascending;

  while (++i < n) {
    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
      xj = xi, j = i;
    }
  }

  if (compare(xj, xj) === 0) return j;
}

function shuffle(array, i0, i1) {
  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
}

function sum(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    }
  }

  else {
    while (++i < n) {
      if (value = +valueof(values[i], i, values)) sum += value;
    }
  }

  return sum;
}

function transpose(matrix) {
  if (!(n = matrix.length)) return [];
  for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }
  return transpose;
}

function length(d) {
  return d.length;
}

function zip() {
  return transpose(arguments);
}

exports.bisect = bisectRight;
exports.bisectRight = bisectRight;
exports.bisectLeft = bisectLeft;
exports.ascending = ascending;
exports.bisector = bisector;
exports.cross = cross;
exports.descending = descending;
exports.deviation = deviation;
exports.extent = extent;
exports.histogram = histogram;
exports.thresholdFreedmanDiaconis = freedmanDiaconis;
exports.thresholdScott = scott;
exports.thresholdSturges = sturges;
exports.max = max;
exports.mean = mean;
exports.median = median;
exports.merge = merge;
exports.min = min;
exports.pairs = pairs;
exports.permute = permute;
exports.quantile = quantile;
exports.range = range;
exports.scan = scan;
exports.shuffle = shuffle;
exports.sum = sum;
exports.ticks = ticks;
exports.tickIncrement = tickIncrement;
exports.tickStep = tickStep;
exports.transpose = transpose;
exports.variance = variance;
exports.zip = zip;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],31:[function(require,module,exports){
// https://d3js.org/d3-axis/ v1.0.12 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var slice = Array.prototype.slice;

function identity(x) {
  return x;
}

var top = 1,
    right = 2,
    bottom = 3,
    left = 4,
    epsilon = 1e-6;

function translateX(x) {
  return "translate(" + (x + 0.5) + ",0)";
}

function translateY(y) {
  return "translate(0," + (y + 0.5) + ")";
}

function number(scale) {
  return function(d) {
    return +scale(d);
  };
}

function center(scale) {
  var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
  if (scale.round()) offset = Math.round(offset);
  return function(d) {
    return +scale(d) + offset;
  };
}

function entering() {
  return !this.__axis;
}

function axis(orient, scale) {
  var tickArguments = [],
      tickValues = null,
      tickFormat = null,
      tickSizeInner = 6,
      tickSizeOuter = 6,
      tickPadding = 3,
      k = orient === top || orient === left ? -1 : 1,
      x = orient === left || orient === right ? "x" : "y",
      transform = orient === top || orient === bottom ? translateX : translateY;

  function axis(context) {
    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity) : tickFormat,
        spacing = Math.max(tickSizeInner, 0) + tickPadding,
        range = scale.range(),
        range0 = +range[0] + 0.5,
        range1 = +range[range.length - 1] + 0.5,
        position = (scale.bandwidth ? center : number)(scale.copy()),
        selection = context.selection ? context.selection() : context,
        path = selection.selectAll(".domain").data([null]),
        tick = selection.selectAll(".tick").data(values, scale).order(),
        tickExit = tick.exit(),
        tickEnter = tick.enter().append("g").attr("class", "tick"),
        line = tick.select("line"),
        text = tick.select("text");

    path = path.merge(path.enter().insert("path", ".tick")
        .attr("class", "domain")
        .attr("stroke", "currentColor"));

    tick = tick.merge(tickEnter);

    line = line.merge(tickEnter.append("line")
        .attr("stroke", "currentColor")
        .attr(x + "2", k * tickSizeInner));

    text = text.merge(tickEnter.append("text")
        .attr("fill", "currentColor")
        .attr(x, k * spacing)
        .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

    if (context !== selection) {
      path = path.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text = text.transition(context);

      tickExit = tickExit.transition(context)
          .attr("opacity", epsilon)
          .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform"); });

      tickEnter
          .attr("opacity", epsilon)
          .attr("transform", function(d) { var p = this.parentNode.__axis; return transform(p && isFinite(p = p(d)) ? p : position(d)); });
    }

    tickExit.remove();

    path
        .attr("d", orient === left || orient == right
            ? (tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter : "M0.5," + range0 + "V" + range1)
            : (tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + ",0.5H" + range1));

    tick
        .attr("opacity", 1)
        .attr("transform", function(d) { return transform(position(d)); });

    line
        .attr(x + "2", k * tickSizeInner);

    text
        .attr(x, k * spacing)
        .text(format);

    selection.filter(entering)
        .attr("fill", "none")
        .attr("font-size", 10)
        .attr("font-family", "sans-serif")
        .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

    selection
        .each(function() { this.__axis = position; });
  }

  axis.scale = function(_) {
    return arguments.length ? (scale = _, axis) : scale;
  };

  axis.ticks = function() {
    return tickArguments = slice.call(arguments), axis;
  };

  axis.tickArguments = function(_) {
    return arguments.length ? (tickArguments = _ == null ? [] : slice.call(_), axis) : tickArguments.slice();
  };

  axis.tickValues = function(_) {
    return arguments.length ? (tickValues = _ == null ? null : slice.call(_), axis) : tickValues && tickValues.slice();
  };

  axis.tickFormat = function(_) {
    return arguments.length ? (tickFormat = _, axis) : tickFormat;
  };

  axis.tickSize = function(_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
  };

  axis.tickSizeInner = function(_) {
    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
  };

  axis.tickSizeOuter = function(_) {
    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
  };

  axis.tickPadding = function(_) {
    return arguments.length ? (tickPadding = +_, axis) : tickPadding;
  };

  return axis;
}

function axisTop(scale) {
  return axis(top, scale);
}

function axisRight(scale) {
  return axis(right, scale);
}

function axisBottom(scale) {
  return axis(bottom, scale);
}

function axisLeft(scale) {
  return axis(left, scale);
}

exports.axisTop = axisTop;
exports.axisRight = axisRight;
exports.axisBottom = axisBottom;
exports.axisLeft = axisLeft;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],32:[function(require,module,exports){
// https://d3js.org/d3-collection/ v1.0.7 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var prefix = "$";

function Map() {}

Map.prototype = map.prototype = {
  constructor: Map,
  has: function(key) {
    return (prefix + key) in this;
  },
  get: function(key) {
    return this[prefix + key];
  },
  set: function(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this) if (property[0] === prefix) delete this[property];
  },
  keys: function() {
    var keys = [];
    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
    return keys;
  },
  values: function() {
    var values = [];
    for (var property in this) if (property[0] === prefix) values.push(this[property]);
    return values;
  },
  entries: function() {
    var entries = [];
    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
    return entries;
  },
  size: function() {
    var size = 0;
    for (var property in this) if (property[0] === prefix) ++size;
    return size;
  },
  empty: function() {
    for (var property in this) if (property[0] === prefix) return false;
    return true;
  },
  each: function(f) {
    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
  }
};

function map(object, f) {
  var map = new Map;

  // Copy constructor.
  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

  // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
    var i = -1,
        n = object.length,
        o;

    if (f == null) while (++i < n) map.set(i, object[i]);
    else while (++i < n) map.set(f(o = object[i], i, object), o);
  }

  // Convert object to map.
  else if (object) for (var key in object) map.set(key, object[key]);

  return map;
}

function nest() {
  var keys = [],
      sortKeys = [],
      sortValues,
      rollup,
      nest;

  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) {
      if (sortValues != null) array.sort(sortValues);
      return rollup != null ? rollup(array) : array;
    }

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        value,
        valuesByKey = map(),
        values,
        result = createResult();

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }

    valuesByKey.each(function(values, key) {
      setResult(result, key, apply(values, depth, createResult, setResult));
    });

    return result;
  }

  function entries(map$$1, depth) {
    if (++depth > keys.length) return map$$1;
    var array, sortKey = sortKeys[depth - 1];
    if (rollup != null && depth >= keys.length) array = map$$1.entries();
    else array = [], map$$1.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
  }

  return nest = {
    object: function(array) { return apply(array, 0, createObject, setObject); },
    map: function(array) { return apply(array, 0, createMap, setMap); },
    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
    key: function(d) { keys.push(d); return nest; },
    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
    sortValues: function(order) { sortValues = order; return nest; },
    rollup: function(f) { rollup = f; return nest; }
  };
}

function createObject() {
  return {};
}

function setObject(object, key, value) {
  object[key] = value;
}

function createMap() {
  return map();
}

function setMap(map$$1, key, value) {
  map$$1.set(key, value);
}

function Set() {}

var proto = map.prototype;

Set.prototype = set.prototype = {
  constructor: Set,
  has: proto.has,
  add: function(value) {
    value += "";
    this[prefix + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set(object, f) {
  var set = new Set;

  // Copy constructor.
  if (object instanceof Set) object.each(function(value) { set.add(value); });

  // Otherwise, assume it’s an array.
  else if (object) {
    var i = -1, n = object.length;
    if (f == null) while (++i < n) set.add(object[i]);
    else while (++i < n) set.add(f(object[i], i, object));
  }

  return set;
}

function keys(map) {
  var keys = [];
  for (var key in map) keys.push(key);
  return keys;
}

function values(map) {
  var values = [];
  for (var key in map) values.push(map[key]);
  return values;
}

function entries(map) {
  var entries = [];
  for (var key in map) entries.push({key: key, value: map[key]});
  return entries;
}

exports.nest = nest;
exports.set = set;
exports.map = map;
exports.keys = keys;
exports.values = values;
exports.entries = entries;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],33:[function(require,module,exports){
// https://d3js.org/d3-color/ v1.2.3 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex3 = /^#([0-9a-f]{3})$/,
    reHex6 = /^#([0-9a-f]{6})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

define(Color, color, {
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: function() {
    return this.rgb().hex();
  },
  toString: function() {
    return this.rgb() + "";
  }
});

function color(format) {
  var m;
  format = (format + "").trim().toLowerCase();
  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00
      : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format])
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

define(Rgb, rgb, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (0 <= this.r && this.r <= 255)
        && (0 <= this.g && this.g <= 255)
        && (0 <= this.b && this.b <= 255)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: function() {
    return "#" + hex(this.r) + hex(this.g) + hex(this.b);
  },
  toString: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(")
        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.b) || 0))
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hsl, hsl, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}

var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;

// https://beta.observablehq.com/@mbostock/lab-and-rgb
var K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) {
    if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
    var h = o.h * deg2rad;
    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
  }
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

define(Lab, lab, extend(Color, {
  brighter: function(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * rad2deg;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hcl, hcl, extend(Color, {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return labConvert(this).rgb();
  }
}));

var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Cubehelix, cubehelix, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));

exports.color = color;
exports.rgb = rgb;
exports.hsl = hsl;
exports.lab = lab;
exports.hcl = hcl;
exports.lch = lch;
exports.gray = gray;
exports.cubehelix = cubehelix;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],34:[function(require,module,exports){
// https://d3js.org/d3-format/ v1.3.2 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimal(1.23) returns ["123", 0].
function formatDecimal(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}

function exponent(x) {
  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
}

function formatGroup(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}

function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  return new FormatSpecifier(specifier);
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  this.fill = match[1] || " ";
  this.align = match[2] || ">";
  this.sign = match[3] || "-";
  this.symbol = match[4] || "";
  this.zero = !!match[5];
  this.width = match[6] && +match[6];
  this.comma = !!match[7];
  this.precision = match[8] && +match[8].slice(1);
  this.trim = !!match[9];
  this.type = match[10] || "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width == null ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};

// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
function formatTrim(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (i0 > 0) { if (!+s[i]) break out; i0 = 0; } break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

var prefixExponent;

function formatPrefixAuto(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}

function formatRounded(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

var formatTypes = {
  "%": function(x, p) { return (x * 100).toFixed(p); },
  "b": function(x) { return Math.round(x).toString(2); },
  "c": function(x) { return x + ""; },
  "d": function(x) { return Math.round(x).toString(10); },
  "e": function(x, p) { return x.toExponential(p); },
  "f": function(x, p) { return x.toFixed(p); },
  "g": function(x, p) { return x.toPrecision(p); },
  "o": function(x) { return Math.round(x).toString(8); },
  "p": function(x, p) { return formatRounded(x * 100, p); },
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
  "x": function(x) { return Math.round(x).toString(16); }
};

function identity(x) {
  return x;
}

var prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

function formatLocale(locale) {
  var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,
      currency = locale.currency,
      decimal = locale.decimal,
      numerals = locale.numerals ? formatNumerals(locale.numerals) : identity,
      percent = locale.percent || "%";

  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!formatTypes[type]) precision == null && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = formatTypes[type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision == null ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Perform the initial formatting.
        var valueNegative = value < 0;
        value = formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = formatTrim(value);

        // If a negative value rounds to zero during formatting, treat as positive.
        if (valueNegative && +value === 0) valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}

var locale;

defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  exports.format = locale.format;
  exports.formatPrefix = locale.formatPrefix;
  return locale;
}

function precisionFixed(step) {
  return Math.max(0, -exponent(Math.abs(step)));
}

function precisionPrefix(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
}

function precisionRound(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, exponent(max) - exponent(step)) + 1;
}

exports.formatDefaultLocale = defaultLocale;
exports.formatLocale = formatLocale;
exports.formatSpecifier = formatSpecifier;
exports.precisionFixed = precisionFixed;
exports.precisionPrefix = precisionPrefix;
exports.precisionRound = precisionRound;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],35:[function(require,module,exports){
// https://d3js.org/d3-interpolate/ v1.3.2 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-color')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-color'], factory) :
(factory((global.d3 = global.d3 || {}),global.d3));
}(this, (function (exports,d3Color) { 'use strict';

function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

function basis$1(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

function basisClosed(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

function constant(x) {
  return function() {
    return x;
  };
}

function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant(isNaN(a) ? b : a);
}

var rgb = (function rgbGamma(y) {
  var color = gamma(y);

  function rgb(start, end) {
    var r = color((start = d3Color.rgb(start)).r, (end = d3Color.rgb(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1);

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = d3Color.rgb(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(basis$1);
var rgbBasisClosed = rgbSpline(basisClosed);

function array(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = value(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}

function date(a, b) {
  var d = new Date;
  return a = +a, b -= a, function(t) {
    return d.setTime(a + b * t), d;
  };
}

function number(a, b) {
  return a = +a, b -= a, function(t) {
    return a + b * t;
  };
}

function object(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = value(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

function string(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: number(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}

function value(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant(b)
      : (t === "number" ? number
      : t === "string" ? ((c = d3Color.color(b)) ? (b = c, rgb) : string)
      : b instanceof d3Color.color ? rgb
      : b instanceof Date ? date
      : Array.isArray(b) ? array
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
      : number)(a, b);
}

function discrete(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

function hue$1(a, b) {
  var i = hue(+a, +b);
  return function(t) {
    var x = i(t);
    return x - 360 * Math.floor(x / 360);
  };
}

function round(a, b) {
  return a = +a, b -= a, function(t) {
    return Math.round(a + b * t);
  };
}

var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

function decompose(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}

var cssNode,
    cssRoot,
    cssView,
    svgNode;

function parseCss(value) {
  if (value === "none") return identity;
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}

function parseSvg(value) {
  if (value == null) return identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}

function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

var rho = Math.SQRT2,
    rho2 = 2,
    rho4 = 4,
    epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

// p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]
function zoom(p0, p1) {
  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
      ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
      dx = ux1 - ux0,
      dy = uy1 - uy0,
      d2 = dx * dx + dy * dy,
      i,
      S;

  // Special case for u0 ≅ u1.
  if (d2 < epsilon2) {
    S = Math.log(w1 / w0) / rho;
    i = function(t) {
      return [
        ux0 + t * dx,
        uy0 + t * dy,
        w0 * Math.exp(rho * t * S)
      ];
    };
  }

  // General case.
  else {
    var d1 = Math.sqrt(d2),
        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    S = (r1 - r0) / rho;
    i = function(t) {
      var s = t * S,
          coshr0 = cosh(r0),
          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
      return [
        ux0 + u * dx,
        uy0 + u * dy,
        w0 * coshr0 / cosh(rho * s + r0)
      ];
    };
  }

  i.duration = S * 1000;

  return i;
}

function hsl(hue$$1) {
  return function(start, end) {
    var h = hue$$1((start = d3Color.hsl(start)).h, (end = d3Color.hsl(end)).h),
        s = nogamma(start.s, end.s),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

var hsl$1 = hsl(hue);
var hslLong = hsl(nogamma);

function lab(start, end) {
  var l = nogamma((start = d3Color.lab(start)).l, (end = d3Color.lab(end)).l),
      a = nogamma(start.a, end.a),
      b = nogamma(start.b, end.b),
      opacity = nogamma(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}

function hcl(hue$$1) {
  return function(start, end) {
    var h = hue$$1((start = d3Color.hcl(start)).h, (end = d3Color.hcl(end)).h),
        c = nogamma(start.c, end.c),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

var hcl$1 = hcl(hue);
var hclLong = hcl(nogamma);

function cubehelix(hue$$1) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix(start, end) {
      var h = hue$$1((start = d3Color.cubehelix(start)).h, (end = d3Color.cubehelix(end)).h),
          s = nogamma(start.s, end.s),
          l = nogamma(start.l, end.l),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix.gamma = cubehelixGamma;

    return cubehelix;
  })(1);
}

var cubehelix$1 = cubehelix(hue);
var cubehelixLong = cubehelix(nogamma);

function piecewise(interpolate, values) {
  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate(v, v = values[++i]);
  return function(t) {
    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i](t - i);
  };
}

function quantize(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
}

exports.interpolate = value;
exports.interpolateArray = array;
exports.interpolateBasis = basis$1;
exports.interpolateBasisClosed = basisClosed;
exports.interpolateDate = date;
exports.interpolateDiscrete = discrete;
exports.interpolateHue = hue$1;
exports.interpolateNumber = number;
exports.interpolateObject = object;
exports.interpolateRound = round;
exports.interpolateString = string;
exports.interpolateTransformCss = interpolateTransformCss;
exports.interpolateTransformSvg = interpolateTransformSvg;
exports.interpolateZoom = zoom;
exports.interpolateRgb = rgb;
exports.interpolateRgbBasis = rgbBasis;
exports.interpolateRgbBasisClosed = rgbBasisClosed;
exports.interpolateHsl = hsl$1;
exports.interpolateHslLong = hslLong;
exports.interpolateLab = lab;
exports.interpolateHcl = hcl$1;
exports.interpolateHclLong = hclLong;
exports.interpolateCubehelix = cubehelix$1;
exports.interpolateCubehelixLong = cubehelixLong;
exports.piecewise = piecewise;
exports.quantize = quantize;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-color":33}],36:[function(require,module,exports){
// https://d3js.org/d3-path/ v1.0.7 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var pi = Math.PI,
    tau = 2 * pi,
    epsilon = 1e-6,
    tauEpsilon = tau - epsilon;

function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath
  this._ = "";
}

function path() {
  return new Path;
}

Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function(x1, y1, x, y) {
    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon));

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Otherwise, draw an arc!
    else {
      var x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }

      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }

    // Is this arc empty? We’re done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau + tau;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
      this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
    }
  },
  rect: function(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
  },
  toString: function() {
    return this._;
  }
};

exports.path = path;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],37:[function(require,module,exports){
// https://d3js.org/d3-scale-chromatic/ v1.3.3 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-interpolate'), require('d3-color')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-interpolate', 'd3-color'], factory) :
(factory((global.d3 = global.d3 || {}),global.d3,global.d3));
}(this, (function (exports,d3Interpolate,d3Color) { 'use strict';

function colors(specifier) {
  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
  while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
  return colors;
}

var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

var Accent = colors("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

var Dark2 = colors("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

var Paired = colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

var Pastel1 = colors("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

var Pastel2 = colors("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

var Set1 = colors("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

var Set2 = colors("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

var Set3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

function ramp(scheme) {
  return d3Interpolate.interpolateRgbBasis(scheme[scheme.length - 1]);
}

var scheme = new Array(3).concat(
  "d8b365f5f5f55ab4ac",
  "a6611adfc27d80cdc1018571",
  "a6611adfc27df5f5f580cdc1018571",
  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
).map(colors);

var BrBG = ramp(scheme);

var scheme$1 = new Array(3).concat(
  "af8dc3f7f7f77fbf7b",
  "7b3294c2a5cfa6dba0008837",
  "7b3294c2a5cff7f7f7a6dba0008837",
  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
).map(colors);

var PRGn = ramp(scheme$1);

var scheme$2 = new Array(3).concat(
  "e9a3c9f7f7f7a1d76a",
  "d01c8bf1b6dab8e1864dac26",
  "d01c8bf1b6daf7f7f7b8e1864dac26",
  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
).map(colors);

var PiYG = ramp(scheme$2);

var scheme$3 = new Array(3).concat(
  "998ec3f7f7f7f1a340",
  "5e3c99b2abd2fdb863e66101",
  "5e3c99b2abd2f7f7f7fdb863e66101",
  "542788998ec3d8daebfee0b6f1a340b35806",
  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
).map(colors);

var PuOr = ramp(scheme$3);

var scheme$4 = new Array(3).concat(
  "ef8a62f7f7f767a9cf",
  "ca0020f4a58292c5de0571b0",
  "ca0020f4a582f7f7f792c5de0571b0",
  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(colors);

var RdBu = ramp(scheme$4);

var scheme$5 = new Array(3).concat(
  "ef8a62ffffff999999",
  "ca0020f4a582bababa404040",
  "ca0020f4a582ffffffbababa404040",
  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
).map(colors);

var RdGy = ramp(scheme$5);

var scheme$6 = new Array(3).concat(
  "fc8d59ffffbf91bfdb",
  "d7191cfdae61abd9e92c7bb6",
  "d7191cfdae61ffffbfabd9e92c7bb6",
  "d73027fc8d59fee090e0f3f891bfdb4575b4",
  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
).map(colors);

var RdYlBu = ramp(scheme$6);

var scheme$7 = new Array(3).concat(
  "fc8d59ffffbf91cf60",
  "d7191cfdae61a6d96a1a9641",
  "d7191cfdae61ffffbfa6d96a1a9641",
  "d73027fc8d59fee08bd9ef8b91cf601a9850",
  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
).map(colors);

var RdYlGn = ramp(scheme$7);

var scheme$8 = new Array(3).concat(
  "fc8d59ffffbf99d594",
  "d7191cfdae61abdda42b83ba",
  "d7191cfdae61ffffbfabdda42b83ba",
  "d53e4ffc8d59fee08be6f59899d5943288bd",
  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
).map(colors);

var Spectral = ramp(scheme$8);

var scheme$9 = new Array(3).concat(
  "e5f5f999d8c92ca25f",
  "edf8fbb2e2e266c2a4238b45",
  "edf8fbb2e2e266c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
).map(colors);

var BuGn = ramp(scheme$9);

var scheme$a = new Array(3).concat(
  "e0ecf49ebcda8856a7",
  "edf8fbb3cde38c96c688419d",
  "edf8fbb3cde38c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
).map(colors);

var BuPu = ramp(scheme$a);

var scheme$b = new Array(3).concat(
  "e0f3dba8ddb543a2ca",
  "f0f9e8bae4bc7bccc42b8cbe",
  "f0f9e8bae4bc7bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
).map(colors);

var GnBu = ramp(scheme$b);

var scheme$c = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(colors);

var OrRd = ramp(scheme$c);

var scheme$d = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(colors);

var PuBuGn = ramp(scheme$d);

var scheme$e = new Array(3).concat(
  "ece7f2a6bddb2b8cbe",
  "f1eef6bdc9e174a9cf0570b0",
  "f1eef6bdc9e174a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
).map(colors);

var PuBu = ramp(scheme$e);

var scheme$f = new Array(3).concat(
  "e7e1efc994c7dd1c77",
  "f1eef6d7b5d8df65b0ce1256",
  "f1eef6d7b5d8df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
).map(colors);

var PuRd = ramp(scheme$f);

var scheme$g = new Array(3).concat(
  "fde0ddfa9fb5c51b8a",
  "feebe2fbb4b9f768a1ae017e",
  "feebe2fbb4b9f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
).map(colors);

var RdPu = ramp(scheme$g);

var scheme$h = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(colors);

var YlGnBu = ramp(scheme$h);

var scheme$i = new Array(3).concat(
  "f7fcb9addd8e31a354",
  "ffffccc2e69978c679238443",
  "ffffccc2e69978c67931a354006837",
  "ffffccd9f0a3addd8e78c67931a354006837",
  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
).map(colors);

var YlGn = ramp(scheme$i);

var scheme$j = new Array(3).concat(
  "fff7bcfec44fd95f0e",
  "ffffd4fed98efe9929cc4c02",
  "ffffd4fed98efe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
).map(colors);

var YlOrBr = ramp(scheme$j);

var scheme$k = new Array(3).concat(
  "ffeda0feb24cf03b20",
  "ffffb2fecc5cfd8d3ce31a1c",
  "ffffb2fecc5cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
).map(colors);

var YlOrRd = ramp(scheme$k);

var scheme$l = new Array(3).concat(
  "deebf79ecae13182bd",
  "eff3ffbdd7e76baed62171b5",
  "eff3ffbdd7e76baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(colors);

var Blues = ramp(scheme$l);

var scheme$m = new Array(3).concat(
  "e5f5e0a1d99b31a354",
  "edf8e9bae4b374c476238b45",
  "edf8e9bae4b374c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(colors);

var Greens = ramp(scheme$m);

var scheme$n = new Array(3).concat(
  "f0f0f0bdbdbd636363",
  "f7f7f7cccccc969696525252",
  "f7f7f7cccccc969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
).map(colors);

var Greys = ramp(scheme$n);

var scheme$o = new Array(3).concat(
  "efedf5bcbddc756bb1",
  "f2f0f7cbc9e29e9ac86a51a3",
  "f2f0f7cbc9e29e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
).map(colors);

var Purples = ramp(scheme$o);

var scheme$p = new Array(3).concat(
  "fee0d2fc9272de2d26",
  "fee5d9fcae91fb6a4acb181d",
  "fee5d9fcae91fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(colors);

var Reds = ramp(scheme$p);

var scheme$q = new Array(3).concat(
  "fee6cefdae6be6550d",
  "feeddefdbe85fd8d3cd94701",
  "feeddefdbe85fd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
).map(colors);

var Oranges = ramp(scheme$q);

var cubehelix = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(300, 0.5, 0.0), d3Color.cubehelix(-240, 0.5, 1.0));

var warm = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(-100, 0.75, 0.35), d3Color.cubehelix(80, 1.50, 0.8));

var cool = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(260, 0.75, 0.35), d3Color.cubehelix(80, 1.50, 0.8));

var c = d3Color.cubehelix();

function rainbow(t) {
  if (t < 0 || t > 1) t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  c.h = 360 * t - 100;
  c.s = 1.5 - 1.5 * ts;
  c.l = 0.8 - 0.9 * ts;
  return c + "";
}

var c$1 = d3Color.rgb(),
    pi_1_3 = Math.PI / 3,
    pi_2_3 = Math.PI * 2 / 3;

function sinebow(t) {
  var x;
  t = (0.5 - t) * Math.PI;
  c$1.r = 255 * (x = Math.sin(t)) * x;
  c$1.g = 255 * (x = Math.sin(t + pi_1_3)) * x;
  c$1.b = 255 * (x = Math.sin(t + pi_2_3)) * x;
  return c$1 + "";
}

function ramp$1(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

var viridis = ramp$1(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

var magma = ramp$1(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

var inferno = ramp$1(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

var plasma = ramp$1(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

exports.schemeCategory10 = category10;
exports.schemeAccent = Accent;
exports.schemeDark2 = Dark2;
exports.schemePaired = Paired;
exports.schemePastel1 = Pastel1;
exports.schemePastel2 = Pastel2;
exports.schemeSet1 = Set1;
exports.schemeSet2 = Set2;
exports.schemeSet3 = Set3;
exports.interpolateBrBG = BrBG;
exports.schemeBrBG = scheme;
exports.interpolatePRGn = PRGn;
exports.schemePRGn = scheme$1;
exports.interpolatePiYG = PiYG;
exports.schemePiYG = scheme$2;
exports.interpolatePuOr = PuOr;
exports.schemePuOr = scheme$3;
exports.interpolateRdBu = RdBu;
exports.schemeRdBu = scheme$4;
exports.interpolateRdGy = RdGy;
exports.schemeRdGy = scheme$5;
exports.interpolateRdYlBu = RdYlBu;
exports.schemeRdYlBu = scheme$6;
exports.interpolateRdYlGn = RdYlGn;
exports.schemeRdYlGn = scheme$7;
exports.interpolateSpectral = Spectral;
exports.schemeSpectral = scheme$8;
exports.interpolateBuGn = BuGn;
exports.schemeBuGn = scheme$9;
exports.interpolateBuPu = BuPu;
exports.schemeBuPu = scheme$a;
exports.interpolateGnBu = GnBu;
exports.schemeGnBu = scheme$b;
exports.interpolateOrRd = OrRd;
exports.schemeOrRd = scheme$c;
exports.interpolatePuBuGn = PuBuGn;
exports.schemePuBuGn = scheme$d;
exports.interpolatePuBu = PuBu;
exports.schemePuBu = scheme$e;
exports.interpolatePuRd = PuRd;
exports.schemePuRd = scheme$f;
exports.interpolateRdPu = RdPu;
exports.schemeRdPu = scheme$g;
exports.interpolateYlGnBu = YlGnBu;
exports.schemeYlGnBu = scheme$h;
exports.interpolateYlGn = YlGn;
exports.schemeYlGn = scheme$i;
exports.interpolateYlOrBr = YlOrBr;
exports.schemeYlOrBr = scheme$j;
exports.interpolateYlOrRd = YlOrRd;
exports.schemeYlOrRd = scheme$k;
exports.interpolateBlues = Blues;
exports.schemeBlues = scheme$l;
exports.interpolateGreens = Greens;
exports.schemeGreens = scheme$m;
exports.interpolateGreys = Greys;
exports.schemeGreys = scheme$n;
exports.interpolatePurples = Purples;
exports.schemePurples = scheme$o;
exports.interpolateReds = Reds;
exports.schemeReds = scheme$p;
exports.interpolateOranges = Oranges;
exports.schemeOranges = scheme$q;
exports.interpolateCubehelixDefault = cubehelix;
exports.interpolateRainbow = rainbow;
exports.interpolateWarm = warm;
exports.interpolateCool = cool;
exports.interpolateSinebow = sinebow;
exports.interpolateViridis = viridis;
exports.interpolateMagma = magma;
exports.interpolateInferno = inferno;
exports.interpolatePlasma = plasma;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-color":33,"d3-interpolate":35}],38:[function(require,module,exports){
// https://d3js.org/d3-scale/ v2.1.2 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-collection'), require('d3-array'), require('d3-interpolate'), require('d3-format'), require('d3-time'), require('d3-time-format')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-collection', 'd3-array', 'd3-interpolate', 'd3-format', 'd3-time', 'd3-time-format'], factory) :
(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3,global.d3,global.d3));
}(this, (function (exports,d3Collection,d3Array,d3Interpolate,d3Format,d3Time,d3TimeFormat) { 'use strict';

var array = Array.prototype;

var map = array.map;
var slice = array.slice;

var implicit = {name: "implicit"};

function ordinal(range) {
  var index = d3Collection.map(),
      domain = [],
      unknown = implicit;

  range = range == null ? [] : slice.call(range);

  function scale(d) {
    var key = d + "", i = index.get(key);
    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }
    return range[(i - 1) % range.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = d3Collection.map();
    var i = -1, n = _.length, d, key;
    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice.call(_), scale) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return scale;
}

function band() {
  var scale = ordinal().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      range = [0, 1],
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = range[1] < range[0],
        start = range[reverse - 0],
        stop = range[1 - reverse];
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = d3Array.range(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = [+_[0], +_[1]], round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band()
        .domain(domain())
        .range(range)
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return rescale();
}

function pointish(scale) {
  var copy = scale.copy;

  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function() {
    return pointish(copy());
  };

  return scale;
}

function point() {
  return pointish(band().paddingInner(1));
}

function constant(x) {
  return function() {
    return x;
  };
}

function number(x) {
  return +x;
}

var unit = [0, 1];

function deinterpolateLinear(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : constant(b);
}

function deinterpolateClamp(deinterpolate) {
  return function(a, b) {
    var d = deinterpolate(a = +a, b = +b);
    return function(x) { return x <= a ? 0 : x >= b ? 1 : d(x); };
  };
}

function reinterpolateClamp(reinterpolate) {
  return function(a, b) {
    var r = reinterpolate(a = +a, b = +b);
    return function(t) { return t <= 0 ? a : t >= 1 ? b : r(t); };
  };
}

function bimap(domain, range, deinterpolate, reinterpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);
  else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range, deinterpolate, reinterpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = deinterpolate(domain[i], domain[i + 1]);
    r[i] = reinterpolate(range[i], range[i + 1]);
  }

  return function(x) {
    var i = d3Array.bisect(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp());
}

// deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].
function continuous(deinterpolate, reinterpolate) {
  var domain = unit,
      range = unit,
      interpolate = d3Interpolate.interpolate,
      clamp = false,
      piecewise,
      output,
      input;

  function rescale() {
    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return (output || (output = piecewise(domain, range, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate)))(+x);
  }

  scale.invert = function(y) {
    return (input || (input = piecewise(range, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = map.call(_, number), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice.call(_), rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = slice.call(_), interpolate = d3Interpolate.interpolateRound, rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, rescale()) : clamp;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };

  return rescale();
}

function tickFormat(domain, count, specifier) {
  var start = domain[0],
      stop = domain[domain.length - 1],
      step = d3Array.tickStep(start, stop, count == null ? 10 : count),
      precision;
  specifier = d3Format.formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = d3Format.precisionPrefix(step, value))) specifier.precision = precision;
      return d3Format.formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = d3Format.precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = d3Format.precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return d3Format.format(specifier);
}

function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return d3Array.ticks(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    return tickFormat(domain(), count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain(),
        i0 = 0,
        i1 = d.length - 1,
        start = d[i0],
        stop = d[i1],
        step;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }

    step = d3Array.tickIncrement(start, stop, count);

    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = d3Array.tickIncrement(start, stop, count);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = d3Array.tickIncrement(start, stop, count);
    }

    if (step > 0) {
      d[i0] = Math.floor(start / step) * step;
      d[i1] = Math.ceil(stop / step) * step;
      domain(d);
    } else if (step < 0) {
      d[i0] = Math.ceil(start * step) / step;
      d[i1] = Math.floor(stop * step) / step;
      domain(d);
    }

    return scale;
  };

  return scale;
}

function linear() {
  var scale = continuous(deinterpolateLinear, d3Interpolate.interpolateNumber);

  scale.copy = function() {
    return copy(scale, linear());
  };

  return linearish(scale);
}

function identity() {
  var domain = [0, 1];

  function scale(x) {
    return +x;
  }

  scale.invert = scale;

  scale.domain = scale.range = function(_) {
    return arguments.length ? (domain = map.call(_, number), scale) : domain.slice();
  };

  scale.copy = function() {
    return identity().domain(domain);
  };

  return linearish(scale);
}

function nice(domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
}

function deinterpolate(a, b) {
  return (b = Math.log(b / a))
      ? function(x) { return Math.log(x / a) / b; }
      : constant(b);
}

function reinterpolate(a, b) {
  return a < 0
      ? function(t) { return -Math.pow(-b, t) * Math.pow(-a, 1 - t); }
      : function(t) { return Math.pow(b, t) * Math.pow(a, 1 - t); };
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10
      : base === Math.E ? Math.exp
      : function(x) { return Math.pow(base, x); };
}

function logp(base) {
  return base === Math.E ? Math.log
      : base === 10 && Math.log10
      || base === 2 && Math.log2
      || (base = Math.log(base), function(x) { return Math.log(x) / base; });
}

function reflect(f) {
  return function(x) {
    return -f(-x);
  };
}

function log() {
  var scale = continuous(deinterpolate, reinterpolate).domain([1, 10]),
      domain = scale.domain,
      base = 10,
      logs = logp(10),
      pows = powp(10);

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows);
    return scale;
  }

  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = function(count) {
    var d = domain(),
        u = d[0],
        v = d[d.length - 1],
        r;

    if (r = v < u) i = u, u = v, v = i;

    var i = logs(u),
        j = logs(v),
        p,
        k,
        t,
        n = count == null ? 10 : +count,
        z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.round(i) - 1, j = Math.round(j) + 1;
      if (u > 0) for (; i < j; ++i) {
        for (k = 1, p = pows(i); k < base; ++k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i < j; ++i) {
        for (k = base - 1, p = pows(i); k >= 1; --k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
    } else {
      z = d3Array.ticks(i, j, Math.min(j - i, n)).map(pows);
    }

    return r ? z.reverse() : z;
  };

  scale.tickFormat = function(count, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = d3Format.format(specifier);
    if (count === Infinity) return specifier;
    if (count == null) count = 10;
    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = function() {
    return domain(nice(domain(), {
      floor: function(x) { return pows(Math.floor(logs(x))); },
      ceil: function(x) { return pows(Math.ceil(logs(x))); }
    }));
  };

  scale.copy = function() {
    return copy(scale, log().base(base));
  };

  return scale;
}

function raise(x, exponent) {
  return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
}

function pow() {
  var exponent = 1,
      scale = continuous(deinterpolate, reinterpolate),
      domain = scale.domain;

  function deinterpolate(a, b) {
    return (b = raise(b, exponent) - (a = raise(a, exponent)))
        ? function(x) { return (raise(x, exponent) - a) / b; }
        : constant(b);
  }

  function reinterpolate(a, b) {
    b = raise(b, exponent) - (a = raise(a, exponent));
    return function(t) { return raise(a + b * t, 1 / exponent); };
  }

  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, domain(domain())) : exponent;
  };

  scale.copy = function() {
    return copy(scale, pow().exponent(exponent));
  };

  return linearish(scale);
}

function sqrt() {
  return pow().exponent(0.5);
}

function quantile() {
  var domain = [],
      range = [],
      thresholds = [];

  function rescale() {
    var i = 0, n = Math.max(1, range.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = d3Array.quantile(domain, i / n);
    return scale;
  }

  function scale(x) {
    if (!isNaN(x = +x)) return range[d3Array.bisect(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(d3Array.ascending);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice.call(_), rescale()) : range.slice();
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile()
        .domain(domain)
        .range(range);
  };

  return scale;
}

function quantize() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range = [0, 1];

  function scale(x) {
    if (x <= x) return range[d3Array.bisect(domain, x, 0, n)];
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
  };

  scale.range = function(_) {
    return arguments.length ? (n = (range = slice.call(_)).length - 1, rescale()) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN]
        : i < 1 ? [x0, domain[0]]
        : i >= n ? [domain[n - 1], x1]
        : [domain[i - 1], domain[i]];
  };

  scale.copy = function() {
    return quantize()
        .domain([x0, x1])
        .range(range);
  };

  return linearish(scale);
}

function threshold() {
  var domain = [0.5],
      range = [0, 1],
      n = 1;

  function scale(x) {
    if (x <= x) return range[d3Array.bisect(domain, x, 0, n)];
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.copy = function() {
    return threshold()
        .domain(domain)
        .range(range);
  };

  return scale;
}

var durationSecond = 1000,
    durationMinute = durationSecond * 60,
    durationHour = durationMinute * 60,
    durationDay = durationHour * 24,
    durationWeek = durationDay * 7,
    durationMonth = durationDay * 30,
    durationYear = durationDay * 365;

function date(t) {
  return new Date(t);
}

function number$1(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
  var scale = continuous(deinterpolateLinear, d3Interpolate.interpolateNumber),
      invert = scale.invert,
      domain = scale.domain;

  var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");

  var tickIntervals = [
    [second,  1,      durationSecond],
    [second,  5,  5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute,  1,      durationMinute],
    [minute,  5,  5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [  hour,  1,      durationHour  ],
    [  hour,  3,  3 * durationHour  ],
    [  hour,  6,  6 * durationHour  ],
    [  hour, 12, 12 * durationHour  ],
    [   day,  1,      durationDay   ],
    [   day,  2,  2 * durationDay   ],
    [  week,  1,      durationWeek  ],
    [ month,  1,      durationMonth ],
    [ month,  3,  3 * durationMonth ],
    [  year,  1,      durationYear  ]
  ];

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond
        : minute(date) < date ? formatSecond
        : hour(date) < date ? formatMinute
        : day(date) < date ? formatHour
        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
        : year(date) < date ? formatMonth
        : formatYear)(date);
  }

  function tickInterval(interval, start, stop, step) {
    if (interval == null) interval = 10;

    // If a desired tick count is specified, pick a reasonable tick interval
    // based on the extent of the domain and a rough estimate of tick size.
    // Otherwise, assume interval is already a time interval and use it.
    if (typeof interval === "number") {
      var target = Math.abs(stop - start) / interval,
          i = d3Array.bisector(function(i) { return i[2]; }).right(tickIntervals, target);
      if (i === tickIntervals.length) {
        step = d3Array.tickStep(start / durationYear, stop / durationYear, interval);
        interval = year;
      } else if (i) {
        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        step = i[1];
        interval = i[0];
      } else {
        step = Math.max(d3Array.tickStep(start, stop, interval), 1);
        interval = millisecond;
      }
    }

    return step == null ? interval : interval.every(step);
  }

  scale.invert = function(y) {
    return new Date(invert(y));
  };

  scale.domain = function(_) {
    return arguments.length ? domain(map.call(_, number$1)) : domain().map(date);
  };

  scale.ticks = function(interval, step) {
    var d = domain(),
        t0 = d[0],
        t1 = d[d.length - 1],
        r = t1 < t0,
        t;
    if (r) t = t0, t0 = t1, t1 = t;
    t = tickInterval(interval, t0, t1, step);
    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
    return r ? t.reverse() : t;
  };

  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };

  scale.nice = function(interval, step) {
    var d = domain();
    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
        ? domain(nice(d, interval))
        : scale;
  };

  scale.copy = function() {
    return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
  };

  return scale;
}

function time() {
  return calendar(d3Time.timeYear, d3Time.timeMonth, d3Time.timeWeek, d3Time.timeDay, d3Time.timeHour, d3Time.timeMinute, d3Time.timeSecond, d3Time.timeMillisecond, d3TimeFormat.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);
}

function utcTime() {
  return calendar(d3Time.utcYear, d3Time.utcMonth, d3Time.utcWeek, d3Time.utcDay, d3Time.utcHour, d3Time.utcMinute, d3Time.utcSecond, d3Time.utcMillisecond, d3TimeFormat.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);
}

function sequential(interpolator) {
  var x0 = 0,
      x1 = 1,
      k10 = 1,
      clamp = false;

  function scale(x) {
    var t = (x - x0) * k10;
    return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], k10 = x0 === x1 ? 0 : 1 / (x1 - x0), scale) : [x0, x1];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.copy = function() {
    return sequential(interpolator).domain([x0, x1]).clamp(clamp);
  };

  return linearish(scale);
}

function diverging(interpolator) {
  var x0 = 0,
      x1 = 0.5,
      x2 = 1,
      k10 = 1,
      k21 = 1,
      clamp = false;

  function scale(x) {
    var t = 0.5 + ((x = +x) - x1) * (x < x1 ? k10 : k21);
    return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], x2 = +_[2], k10 = x0 === x1 ? 0 : 0.5 / (x1 - x0), k21 = x1 === x2 ? 0 : 0.5 / (x2 - x1), scale) : [x0, x1, x2];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.copy = function() {
    return diverging(interpolator).domain([x0, x1, x2]).clamp(clamp);
  };

  return linearish(scale);
}

exports.scaleBand = band;
exports.scalePoint = point;
exports.scaleIdentity = identity;
exports.scaleLinear = linear;
exports.scaleLog = log;
exports.scaleOrdinal = ordinal;
exports.scaleImplicit = implicit;
exports.scalePow = pow;
exports.scaleSqrt = sqrt;
exports.scaleQuantile = quantile;
exports.scaleQuantize = quantize;
exports.scaleThreshold = threshold;
exports.scaleTime = time;
exports.scaleUtc = utcTime;
exports.scaleSequential = sequential;
exports.scaleDiverging = diverging;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-array":30,"d3-collection":32,"d3-format":34,"d3-interpolate":35,"d3-time":42,"d3-time-format":41}],39:[function(require,module,exports){
// https://d3js.org/d3-selection/ v1.3.2 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var xhtml = "http://www.w3.org/1999/xhtml";

var namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

function namespace(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
}

function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === xhtml && document.documentElement.namespaceURI === xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

function creator(name) {
  var fullname = namespace(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
}

function none() {}

function selector(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

function selection_select(select) {
  if (typeof select !== "function") select = selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new Selection(subgroups, this._parents);
}

function empty() {
  return [];
}

function selectorAll(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}

function selection_selectAll(select) {
  if (typeof select !== "function") select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new Selection(subgroups, parents);
}

var matcher = function(selector) {
  return function() {
    return this.matches(selector);
  };
};

if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!element.matches) {
    var vendorMatches = element.webkitMatchesSelector
        || element.msMatchesSelector
        || element.mozMatchesSelector
        || element.oMatchesSelector;
    matcher = function(selector) {
      return function() {
        return vendorMatches.call(this, selector);
      };
    };
  }
}

var matcher$1 = matcher;

function selection_filter(match) {
  if (typeof match !== "function") match = matcher$1(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Selection(subgroups, this._parents);
}

function sparse(update) {
  return new Array(update.length);
}

function selection_enter() {
  return new Selection(this._enter || this._groups.map(sparse), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};

function constant(x) {
  return function() {
    return x;
  };
}

var keyPrefix = "$"; // Protect against keys like “__proto__”.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that don’t fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);
    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
      exit[i] = node;
    }
  }
}

function selection_data(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function(d) { data[++j] = d; });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = constant(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}

function selection_exit() {
  return new Selection(this._exit || this._groups.map(sparse), this._parents);
}

function selection_merge(selection$$1) {

  for (var groups0 = this._groups, groups1 = selection$$1._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Selection(merges, this._parents);
}

function selection_order() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}

function selection_sort(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new Selection(sortgroups, this._parents).order();
}

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function selection_call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

function selection_nodes() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() { nodes[++i] = this; });
  return nodes;
}

function selection_node() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}

function selection_size() {
  var size = 0;
  this.each(function() { ++size; });
  return size;
}

function selection_empty() {
  return !this.node();
}

function selection_each(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}

function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

function selection_attr(name, value) {
  var fullname = namespace(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
}

function defaultView(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

function selection_style(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
}

function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

function selection_property(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
}

function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

function selection_classed(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
}

function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

function selection_text(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
}

function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

function selection_html(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
}

function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

function selection_raise() {
  return this.each(raise);
}

function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

function selection_lower() {
  return this.each(lower);
}

function selection_append(name) {
  var create = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}

function constantNull() {
  return null;
}

function selection_insert(name, before) {
  var create = typeof name === "function" ? name : creator(name),
      select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

function selection_remove() {
  return this.each(remove);
}

function selection_cloneShallow() {
  return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
}

function selection_cloneDeep() {
  return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
}

function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

function selection_datum(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
}

var filterEvents = {};

exports.event = null;

if (typeof document !== "undefined") {
  var element$1 = document.documentElement;
  if (!("onmouseenter" in element$1)) {
    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function(event) {
    var related = event.relatedTarget;
    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function(event1) {
    var event0 = exports.event; // Events can be reentrant (e.g., focus).
    exports.event = event1;
    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      exports.event = event0;
    }
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group) {
    var on = this.__on, o, listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

function selection_on(typename, value, capture) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
  return this;
}

function customEvent(event1, listener, that, args) {
  var event0 = exports.event;
  event1.sourceEvent = exports.event;
  exports.event = event1;
  try {
    return listener.apply(that, args);
  } finally {
    exports.event = event0;
  }
}

function dispatchEvent(node, type, params) {
  var window = defaultView(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

function selection_dispatch(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
}

var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: selection_select,
  selectAll: selection_selectAll,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  merge: selection_merge,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch
};

function select(selector) {
  return typeof selector === "string"
      ? new Selection([[document.querySelector(selector)]], [document.documentElement])
      : new Selection([[selector]], root);
}

function create(name) {
  return select(creator(name).call(document.documentElement));
}

var nextId = 0;

function local() {
  return new Local;
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};

function sourceEvent() {
  var current = exports.event, source;
  while (source = current.sourceEvent) current = source;
  return current;
}

function point(node, event) {
  var svg = node.ownerSVGElement || node;

  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX, point.y = event.clientY;
    point = point.matrixTransform(node.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = node.getBoundingClientRect();
  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
}

function mouse(node) {
  var event = sourceEvent();
  if (event.changedTouches) event = event.changedTouches[0];
  return point(node, event);
}

function selectAll(selector) {
  return typeof selector === "string"
      ? new Selection([document.querySelectorAll(selector)], [document.documentElement])
      : new Selection([selector == null ? [] : selector], root);
}

function touch(node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;

  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return point(node, touch);
    }
  }

  return null;
}

function touches(node, touches) {
  if (touches == null) touches = sourceEvent().touches;

  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = point(node, touches[i]);
  }

  return points;
}

exports.create = create;
exports.creator = creator;
exports.local = local;
exports.matcher = matcher$1;
exports.mouse = mouse;
exports.namespace = namespace;
exports.namespaces = namespaces;
exports.clientPoint = point;
exports.select = select;
exports.selectAll = selectAll;
exports.selection = selection;
exports.selector = selector;
exports.selectorAll = selectorAll;
exports.style = styleValue;
exports.touch = touch;
exports.touches = touches;
exports.window = defaultView;
exports.customEvent = customEvent;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],40:[function(require,module,exports){
// https://d3js.org/d3-shape/ v1.2.2 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-path')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-path'], factory) :
(factory((global.d3 = global.d3 || {}),global.d3));
}(this, (function (exports,d3Path) { 'use strict';

function constant(x) {
  return function constant() {
    return x;
  };
}

var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max = Math.max;
var min = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;

var epsilon = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}

function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

function arc() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = constant(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - halfPi,
        a1 = endAngle.apply(this, arguments) - halfPi,
        da = abs(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = d3Path.path();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > epsilon)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > tau - epsilon) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > epsilon) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),
          rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
      if (rp > epsilon) {
        var p0 = asin(rp / r0 * sin(ap)),
            p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p0 * 2) > epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * cos(a01),
          y01 = r1 * sin(a01),
          x10 = r0 * cos(a10),
          y10 = r0 * sin(a10);

      // Apply rounded corners?
      if (rc > epsilon) {
        var x11 = r1 * cos(a11),
            y11 = r1 * sin(a11),
            x00 = r0 * cos(a00),
            y00 = r0 * sin(a00);

        // Restrict the corner radius according to the sector angle.
        if (da < pi) {
          var oc = da0 > epsilon ? intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],
              ax = x01 - oc[0],
              ay = y01 - oc[1],
              bx = x11 - oc[0],
              by = y11 - oc[1],
              kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
              lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = min(rc, (r0 - lc) / (kc - 1));
          rc1 = min(rc, (r1 - lc) / (kc + 1));
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > epsilon)) context.moveTo(x01, y01);

      // Does the sector’s outer ring have rounded corners?
      else if (rc1 > epsilon) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and it’s a circular sector?
      // Or perhaps it’s an annular sector collapsed due to padding?
      if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);

      // Does the sector’s inner ring (or point) have rounded corners?
      else if (rc0 > epsilon) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
    return [cos(a) * r, sin(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
}

function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: this._context.lineTo(x, y); break;
    }
  }
};

function curveLinear(context) {
  return new Linear(context);
}

function x(p) {
  return p[0];
}

function y(p) {
  return p[1];
}

function line() {
  var x$$1 = x,
      y$$1 = y,
      defined = constant(true),
      context = null,
      curve = curveLinear,
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = d3Path.path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x$$1(d, i, data), +y$$1(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant(+_), line) : x$$1;
  };

  line.y = function(_) {
    return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant(+_), line) : y$$1;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
}

function area() {
  var x0 = x,
      x1 = null,
      y0 = constant(0),
      y1 = y,
      defined = constant(true),
      context = null,
      curve = curveLinear,
      output = null;

  function area(data) {
    var i,
        j,
        k,
        n = data.length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = d3Path.path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return line().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
}

function descending(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

function identity(d) {
  return d;
}

function pie() {
  var value = identity,
      sortValues = descending,
      sort = null,
      startAngle = constant(0),
      endAngle = constant(tau),
      padAngle = constant(0);

  function pie(data) {
    var i,
        n = data.length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    }

    // Optionally sort the arcs by previously-computed values or by data.
    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

    // Compute the arcs! They are stored in the original data's order.
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), pie) : value;
  };

  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), pie) : startAngle;
  };

  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), pie) : endAngle;
  };

  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), pie) : padAngle;
  };

  return pie;
}

var curveRadialLinear = curveRadial(curveLinear);

function Radial(curve) {
  this._curve = curve;
}

Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a, r) {
    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
  }
};

function curveRadial(curve) {

  function radial(context) {
    return new Radial(curve(context));
  }

  radial._curve = curve;

  return radial;
}

function lineRadial(l) {
  var c = l.curve;

  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;

  l.curve = function(_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };

  return l;
}

function lineRadial$1() {
  return lineRadial(line().curve(curveRadialLinear));
}

function areaRadial() {
  var a = area().curve(curveRadialLinear),
      c = a.curve,
      x0 = a.lineX0,
      x1 = a.lineX1,
      y0 = a.lineY0,
      y1 = a.lineY1;

  a.angle = a.x, delete a.x;
  a.startAngle = a.x0, delete a.x0;
  a.endAngle = a.x1, delete a.x1;
  a.radius = a.y, delete a.y;
  a.innerRadius = a.y0, delete a.y0;
  a.outerRadius = a.y1, delete a.y1;
  a.lineStartAngle = function() { return lineRadial(x0()); }, delete a.lineX0;
  a.lineEndAngle = function() { return lineRadial(x1()); }, delete a.lineX1;
  a.lineInnerRadius = function() { return lineRadial(y0()); }, delete a.lineY0;
  a.lineOuterRadius = function() { return lineRadial(y1()); }, delete a.lineY1;

  a.curve = function(_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };

  return a;
}

function pointRadial(x, y) {
  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
}

var slice = Array.prototype.slice;

function linkSource(d) {
  return d.source;
}

function linkTarget(d) {
  return d.target;
}

function link(curve) {
  var source = linkSource,
      target = linkTarget,
      x$$1 = x,
      y$$1 = y,
      context = null;

  function link() {
    var buffer, argv = slice.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
    if (!context) context = buffer = d3Path.path();
    curve(context, +x$$1.apply(this, (argv[0] = s, argv)), +y$$1.apply(this, argv), +x$$1.apply(this, (argv[0] = t, argv)), +y$$1.apply(this, argv));
    if (buffer) return context = null, buffer + "" || null;
  }

  link.source = function(_) {
    return arguments.length ? (source = _, link) : source;
  };

  link.target = function(_) {
    return arguments.length ? (target = _, link) : target;
  };

  link.x = function(_) {
    return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant(+_), link) : x$$1;
  };

  link.y = function(_) {
    return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant(+_), link) : y$$1;
  };

  link.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), link) : context;
  };

  return link;
}

function curveHorizontal(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
}

function curveVertical(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
}

function curveRadial$1(context, x0, y0, x1, y1) {
  var p0 = pointRadial(x0, y0),
      p1 = pointRadial(x0, y0 = (y0 + y1) / 2),
      p2 = pointRadial(x1, y0),
      p3 = pointRadial(x1, y1);
  context.moveTo(p0[0], p0[1]);
  context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
}

function linkHorizontal() {
  return link(curveHorizontal);
}

function linkVertical() {
  return link(curveVertical);
}

function linkRadial() {
  var l = link(curveRadial$1);
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  return l;
}

var circle = {
  draw: function(context, size) {
    var r = Math.sqrt(size / pi);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, tau);
  }
};

var cross = {
  draw: function(context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
};

var tan30 = Math.sqrt(1 / 3),
    tan30_2 = tan30 * 2;

var diamond = {
  draw: function(context, size) {
    var y = Math.sqrt(size / tan30_2),
        x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
};

var ka = 0.89081309152928522810,
    kr = Math.sin(pi / 10) / Math.sin(7 * pi / 10),
    kx = Math.sin(tau / 10) * kr,
    ky = -Math.cos(tau / 10) * kr;

var star = {
  draw: function(context, size) {
    var r = Math.sqrt(size * ka),
        x = kx * r,
        y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);
    for (var i = 1; i < 5; ++i) {
      var a = tau * i / 5,
          c = Math.cos(a),
          s = Math.sin(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }
    context.closePath();
  }
};

var square = {
  draw: function(context, size) {
    var w = Math.sqrt(size),
        x = -w / 2;
    context.rect(x, x, w, w);
  }
};

var sqrt3 = Math.sqrt(3);

var triangle = {
  draw: function(context, size) {
    var y = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
};

var c = -0.5,
    s = Math.sqrt(3) / 2,
    k = 1 / Math.sqrt(12),
    a = (k / 2 + 1) * 3;

var wye = {
  draw: function(context, size) {
    var r = Math.sqrt(size / a),
        x0 = r / 2,
        y0 = r * k,
        x1 = x0,
        y1 = r * k + r,
        x2 = -x1,
        y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
};

var symbols = [
  circle,
  cross,
  diamond,
  square,
  star,
  triangle,
  wye
];

function symbol() {
  var type = constant(circle),
      size = constant(64),
      context = null;

  function symbol() {
    var buffer;
    if (!context) context = buffer = d3Path.path();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : constant(_), symbol) : type;
  };

  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant(+_), symbol) : size;
  };

  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
}

function noop() {}

function point(that, x, y) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x) / 6,
    (that._y0 + 4 * that._y1 + y) / 6
  );
}

function Basis(context) {
  this._context = context;
}

Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3: point(this, this._x1, this._y1); // proceed
      case 2: this._context.lineTo(this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function basis(context) {
  return new Basis(context);
}

function BasisClosed(context) {
  this._context = context;
}

BasisClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function basisClosed(context) {
  return new BasisClosed(context);
}

function BasisOpen(context) {
  this._context = context;
}

BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
      case 3: this._point = 4; // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function basisOpen(context) {
  return new BasisOpen(context);
}

function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}

Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }

    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

var bundle = (function custom(beta) {

  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }

  bundle.beta = function(beta) {
    return custom(+beta);
  };

  return bundle;
})(0.85);

function point$1(that, x, y) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x),
    that._y2 + that._k * (that._y1 - y),
    that._x2,
    that._y2
  );
}

function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: point$1(this, this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
      case 2: this._point = 3; // proceed
      default: point$1(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinal = (function custom(tension) {

  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: point$1(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinalClosed = (function custom(tension) {

  function cardinal$$1(context) {
    return new CardinalClosed(context, tension);
  }

  cardinal$$1.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal$$1;
})(0);

function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: point$1(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinalOpen = (function custom(tension) {

  function cardinal$$1(context) {
    return new CardinalOpen(context, tension);
  }

  cardinal$$1.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal$$1;
})(0);

function point$2(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > epsilon) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > epsilon) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: this.point(this._x2, this._y2); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; // proceed
      default: point$2(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRom = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: point$2(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRomClosed = (function custom(alpha) {

  function catmullRom$$1(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }

  catmullRom$$1.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom$$1;
})(0.5);

function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: point$2(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRomOpen = (function custom(alpha) {

  function catmullRom$$1(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }

  catmullRom$$1.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom$$1;
})(0.5);

function LinearClosed(context) {
  this._context = context;
}

LinearClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);
    else this._point = 1, this._context.moveTo(x, y);
  }
};

function linearClosed(context) {
  return new LinearClosed(context);
}

function sign(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function point$3(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 =
    this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x1, this._y1); break;
      case 3: point$3(this, this._t0, slope2(this, this._t0)); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; point$3(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
      default: point$3(this, this._t0, t1 = slope3(this, x, y)); break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
};

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function(x, y) { this._context.moveTo(y, x); },
  closePath: function() { this._context.closePath(); },
  lineTo: function(x, y) { this._context.lineTo(y, x); },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
};

function monotoneX(context) {
  return new MonotoneX(context);
}

function monotoneY(context) {
  return new MonotoneY(context);
}

function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
  b[n - 1] = (x[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
  return [a, b];
}

function natural(context) {
  return new Natural(context);
}

function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y);
          this._context.lineTo(x, y);
        } else {
          var x1 = this._x * (1 - this._t) + x * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y);
        }
        break;
      }
    }
    this._x = x, this._y = y;
  }
};

function step(context) {
  return new Step(context, 0.5);
}

function stepBefore(context) {
  return new Step(context, 0);
}

function stepAfter(context) {
  return new Step(context, 1);
}

function none(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}

function none$1(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0) o[n] = n;
  return o;
}

function stackValue(d, key) {
  return d[key];
}

function stack() {
  var keys = constant([]),
      order = none$1,
      offset = none,
      value = stackValue;

  function stack(data) {
    var kz = keys.apply(this, arguments),
        i,
        m = data.length,
        n = kz.length,
        sz = new Array(n),
        oz;

    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }
      si.key = ki;
    }

    for (i = 0, oz = order(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }

    offset(sz, oz);
    return sz;
  }

  stack.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : constant(slice.call(_)), stack) : keys;
  };

  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), stack) : value;
  };

  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? none$1 : typeof _ === "function" ? _ : constant(slice.call(_)), stack) : order;
  };

  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? none : _, stack) : offset;
  };

  return stack;
}

function expand(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
  }
  none(series, order);
}

function diverging(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order[i]][j])[1] - d[0]) >= 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = yp;
      }
    }
  }
}

function silhouette(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y / 2;
  }
  none(series, order);
}

function wiggle(series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]],
          sij0 = si[j][1] || 0,
          sij1 = si[j - 1][1] || 0,
          s3 = (sij0 - sij1) / 2;
      for (var k = 0; k < i; ++k) {
        var sk = series[order[k]],
            skj0 = sk[j][1] || 0,
            skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    if (s1) y -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y;
  none(series, order);
}

function ascending(series) {
  var sums = series.map(sum);
  return none$1(series).sort(function(a, b) { return sums[a] - sums[b]; });
}

function sum(series) {
  var s = 0, i = -1, n = series.length, v;
  while (++i < n) if (v = +series[i][1]) s += v;
  return s;
}

function descending$1(series) {
  return ascending(series).reverse();
}

function insideOut(series) {
  var n = series.length,
      i,
      j,
      sums = series.map(sum),
      order = none$1(series).sort(function(a, b) { return sums[b] - sums[a]; }),
      top = 0,
      bottom = 0,
      tops = [],
      bottoms = [];

  for (i = 0; i < n; ++i) {
    j = order[i];
    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }

  return bottoms.reverse().concat(tops);
}

function reverse(series) {
  return none$1(series).reverse();
}

exports.arc = arc;
exports.area = area;
exports.line = line;
exports.pie = pie;
exports.areaRadial = areaRadial;
exports.radialArea = areaRadial;
exports.lineRadial = lineRadial$1;
exports.radialLine = lineRadial$1;
exports.pointRadial = pointRadial;
exports.linkHorizontal = linkHorizontal;
exports.linkVertical = linkVertical;
exports.linkRadial = linkRadial;
exports.symbol = symbol;
exports.symbols = symbols;
exports.symbolCircle = circle;
exports.symbolCross = cross;
exports.symbolDiamond = diamond;
exports.symbolSquare = square;
exports.symbolStar = star;
exports.symbolTriangle = triangle;
exports.symbolWye = wye;
exports.curveBasisClosed = basisClosed;
exports.curveBasisOpen = basisOpen;
exports.curveBasis = basis;
exports.curveBundle = bundle;
exports.curveCardinalClosed = cardinalClosed;
exports.curveCardinalOpen = cardinalOpen;
exports.curveCardinal = cardinal;
exports.curveCatmullRomClosed = catmullRomClosed;
exports.curveCatmullRomOpen = catmullRomOpen;
exports.curveCatmullRom = catmullRom;
exports.curveLinearClosed = linearClosed;
exports.curveLinear = curveLinear;
exports.curveMonotoneX = monotoneX;
exports.curveMonotoneY = monotoneY;
exports.curveNatural = natural;
exports.curveStep = step;
exports.curveStepAfter = stepAfter;
exports.curveStepBefore = stepBefore;
exports.stack = stack;
exports.stackOffsetExpand = expand;
exports.stackOffsetDiverging = diverging;
exports.stackOffsetNone = none;
exports.stackOffsetSilhouette = silhouette;
exports.stackOffsetWiggle = wiggle;
exports.stackOrderAscending = ascending;
exports.stackOrderDescending = descending$1;
exports.stackOrderInsideOut = insideOut;
exports.stackOrderNone = none$1;
exports.stackOrderReverse = reverse;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-path":36}],41:[function(require,module,exports){
// https://d3js.org/d3-time-format/ v2.1.3 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-time')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-time'], factory) :
(factory((global.d3 = global.d3 || {}),global.d3));
}(this, (function (exports,d3Time) { 'use strict';

function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newYear(y) {
  return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, newDate) {
    return function(string) {
      var d = newYear(1900),
          i = parseSpecifier(d, specifier, string += "", 0),
          week, day;
      if (i != string.length) return null;

      // If a UNIX timestamp is specified, return it.
      if ("Q" in d) return new Date(d.Q);

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newYear(d.y)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? d3Time.utcMonday.ceil(week) : d3Time.utcMonday(week);
          week = d3Time.utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = newDate(newYear(d.y)), day = week.getDay();
          week = day > 4 || day === 0 ? d3Time.timeMonday.ceil(week) : d3Time.timeMonday(week);
          week = d3Time.timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return newDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", localDate);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier, utcDate);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"},
    numberRe = /^\s*\d+/, // note: ignores next directive
    percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  var map = {}, i = -1, n = names.length;
  while (++i < n) map[names[i].toLowerCase()] = i;
  return map;
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = (+n[0]) * 1000, i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + d3Time.timeDay.count(d3Time.timeYear(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(d3Time.timeSunday.count(d3Time.timeYear(d), d), p, 2);
}

function formatWeekNumberISO(d, p) {
  var day = d.getDay();
  d = (day >= 4 || day === 0) ? d3Time.timeThursday(d) : d3Time.timeThursday.ceil(d);
  return pad(d3Time.timeThursday.count(d3Time.timeYear(d), d) + (d3Time.timeYear(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(d3Time.timeMonday.count(d3Time.timeYear(d), d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + d3Time.utcDay.count(d3Time.utcYear(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(d3Time.utcSunday.count(d3Time.utcYear(d), d), p, 2);
}

function formatUTCWeekNumberISO(d, p) {
  var day = d.getUTCDay();
  d = (day >= 4 || day === 0) ? d3Time.utcThursday(d) : d3Time.utcThursday.ceil(d);
  return pad(d3Time.utcThursday.count(d3Time.utcYear(d), d) + (d3Time.utcYear(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(d3Time.utcMonday.count(d3Time.utcYear(d), d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}

var locale;

defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  exports.timeFormat = locale.format;
  exports.timeParse = locale.parse;
  exports.utcFormat = locale.utcFormat;
  exports.utcParse = locale.utcParse;
  return locale;
}

var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

function formatIsoNative(date) {
  return date.toISOString();
}

var formatIso = Date.prototype.toISOString
    ? formatIsoNative
    : exports.utcFormat(isoSpecifier);

function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}

var parseIso = +new Date("2000-01-01T00:00:00.000Z")
    ? parseIsoNative
    : exports.utcParse(isoSpecifier);

exports.timeFormatDefaultLocale = defaultLocale;
exports.timeFormatLocale = formatLocale;
exports.isoFormat = formatIso;
exports.isoParse = parseIso;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-time":42}],42:[function(require,module,exports){
// https://d3js.org/d3-time/ v1.0.10 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var t0 = new Date,
    t1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = new Date(+date)), date;
  }

  interval.floor = interval;

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [], previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}

var millisecond = newInterval(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return newInterval(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};
var milliseconds = millisecond.range;

var durationSecond = 1e3;
var durationMinute = 6e4;
var durationHour = 36e5;
var durationDay = 864e5;
var durationWeek = 6048e5;

var second = newInterval(function(date) {
  date.setTime(Math.floor(date / durationSecond) * durationSecond);
}, function(date, step) {
  date.setTime(+date + step * durationSecond);
}, function(start, end) {
  return (end - start) / durationSecond;
}, function(date) {
  return date.getUTCSeconds();
});
var seconds = second.range;

var minute = newInterval(function(date) {
  date.setTime(Math.floor(date / durationMinute) * durationMinute);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getMinutes();
});
var minutes = minute.range;

var hour = newInterval(function(date) {
  var offset = date.getTimezoneOffset() * durationMinute % durationHour;
  if (offset < 0) offset += durationHour;
  date.setTime(Math.floor((+date - offset) / durationHour) * durationHour + offset);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getHours();
});
var hours = hour.range;

var day = newInterval(function(date) {
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setDate(date.getDate() + step);
}, function(start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
}, function(date) {
  return date.getDate() - 1;
});
var days = day.range;

function weekday(i) {
  return newInterval(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;

var month = newInterval(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});
var months = month.range;

var year = newInterval(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};
var years = year.range;

var utcMinute = newInterval(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getUTCMinutes();
});
var utcMinutes = utcMinute.range;

var utcHour = newInterval(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getUTCHours();
});
var utcHours = utcHour.range;

var utcDay = newInterval(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / durationDay;
}, function(date) {
  return date.getUTCDate() - 1;
});
var utcDays = utcDay.range;

function utcWeekday(i) {
  return newInterval(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / durationWeek;
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

var utcMonth = newInterval(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});
var utcMonths = utcMonth.range;

var utcYear = newInterval(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};
var utcYears = utcYear.range;

exports.timeInterval = newInterval;
exports.timeMillisecond = millisecond;
exports.timeMilliseconds = milliseconds;
exports.utcMillisecond = millisecond;
exports.utcMilliseconds = milliseconds;
exports.timeSecond = second;
exports.timeSeconds = seconds;
exports.utcSecond = second;
exports.utcSeconds = seconds;
exports.timeMinute = minute;
exports.timeMinutes = minutes;
exports.timeHour = hour;
exports.timeHours = hours;
exports.timeDay = day;
exports.timeDays = days;
exports.timeWeek = sunday;
exports.timeWeeks = sundays;
exports.timeSunday = sunday;
exports.timeSundays = sundays;
exports.timeMonday = monday;
exports.timeMondays = mondays;
exports.timeTuesday = tuesday;
exports.timeTuesdays = tuesdays;
exports.timeWednesday = wednesday;
exports.timeWednesdays = wednesdays;
exports.timeThursday = thursday;
exports.timeThursdays = thursdays;
exports.timeFriday = friday;
exports.timeFridays = fridays;
exports.timeSaturday = saturday;
exports.timeSaturdays = saturdays;
exports.timeMonth = month;
exports.timeMonths = months;
exports.timeYear = year;
exports.timeYears = years;
exports.utcMinute = utcMinute;
exports.utcMinutes = utcMinutes;
exports.utcHour = utcHour;
exports.utcHours = utcHours;
exports.utcDay = utcDay;
exports.utcDays = utcDays;
exports.utcWeek = utcSunday;
exports.utcWeeks = utcSundays;
exports.utcSunday = utcSunday;
exports.utcSundays = utcSundays;
exports.utcMonday = utcMonday;
exports.utcMondays = utcMondays;
exports.utcTuesday = utcTuesday;
exports.utcTuesdays = utcTuesdays;
exports.utcWednesday = utcWednesday;
exports.utcWednesdays = utcWednesdays;
exports.utcThursday = utcThursday;
exports.utcThursdays = utcThursdays;
exports.utcFriday = utcFriday;
exports.utcFridays = utcFridays;
exports.utcSaturday = utcSaturday;
exports.utcSaturdays = utcSaturdays;
exports.utcMonth = utcMonth;
exports.utcMonths = utcMonths;
exports.utcYear = utcYear;
exports.utcYears = utcYears;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],43:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],44:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":43,"ieee754":46}],45:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],46:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}]},{},[5]);
